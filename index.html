<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Leon H-Arts: Галерея Фанфиков (Fixed Scroll)</title>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React / Firebase / Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase libs will be imported as module inside script block -->
    <style>
      body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; background:#f8fafc; }
      .text-with-shadow { color: white; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; }
      .fixed-click-zone { position: fixed; top:50%; transform:translateY(-50%); width:20%; height:50%; z-index:65; cursor:pointer; display:flex; align-items:center; }
      .fixed-click-zone.left { left:0; justify-content:flex-start; }
      .fixed-click-zone.right { right:0; justify-content:flex-end; }
    </style>
</head>
<body>
<div id="root"></div>

<script type="module">
  // импорт Firebase (точно так же как в твоём оригинале)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
  import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
  import { getFirestore, doc, collection, query, onSnapshot, updateDoc, addDoc, arrayUnion, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

  // Экспортим в window, чтобы старый JSX-скрипт ниже мог ссылаться (как в оригинале)
  window.initializeApp = initializeApp;
  window.getAuth = getAuth;
  window.signInAnonymously = signInAnonymously;
  window.signInWithCustomToken = signInWithCustomToken;
  window.onAuthStateChanged = onAuthStateChanged;
  window.signInWithEmailAndPassword = signInWithEmailAndPassword;
  window.signOut = signOut;
  window.getFirestore = getFirestore;
  window.doc = doc;
  window.collection = collection;
  window.query = query;
  window.onSnapshot = onSnapshot;
  window.updateDoc = updateDoc;
  window.addDoc = addDoc;
  window.arrayUnion = arrayUnion;
  window.serverTimestamp = serverTimestamp;

  // Те же глобальные переменные, что были в исходнике (если Canvas/окружение задавало)
  if (typeof window.__app_id === 'undefined') window.__app_id = 'default-app-id';
  if (typeof window.__initial_auth_token === 'undefined') window.__initial_auth_token = null;
  if (typeof window.__firebase_config === 'undefined') {
    // Вставил тот же конфиг, который был в исходнике — если хочешь, заменю
    window.__firebase_config = JSON.stringify({
      apiKey: "AIzaSyBpThMaS36IkmAqUrvk9WpWi0AhOhndhU8",
      authDomain: "leon-h-arts-6b69b.firebaseapp.com",
      projectId: "leon-h-arts-6b69b",
      storageBucket: "leon-h-arts-6b69b.firebasestorage.app",
      messagingSenderId: "162244900947",
      appId: "1:162244900947:web:0d265bc4fe5639380ceea6"
    });
  }
</script>

<!-- Основной React-код — использует window.*/ переменные (Babel JSX) -->
<script type="text/babel">
/* global initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
   signInWithEmailAndPassword, signOut, getFirestore, doc, collection, query, onSnapshot, updateDoc,
   addDoc, arrayUnion, serverTimestamp
*/
const { useState, useEffect, useRef, useCallback, useMemo, useLayoutEffect } = React;

// Небольшие SVG-иконки (взяты из твоего файла)
const Icon = ({ children, size=24, className='' , ...p}) => (
  <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...p}>{children}</svg>
);
const X = props => (<Icon {...props}><line x1="18" x2="6" y1="6" y2="18"/><line x1="6" x2="18" y1="6" y2="18"/></Icon>);
const ChevronLeft = props => (<Icon {...props}><path d="m15 18-6-6 6-6"/></Icon>);
const ChevronRight = props => (<Icon {...props}><path d="m9 18 6-6-6-6"/></Icon>);
const Trash2 = props => (<Icon {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></Icon>);
const ImageIcon = props => (<Icon {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></Icon>);
const Loader = props => (<Icon {...props}><path d="M12 2v4" /><path d="M12 18v4" /><path d="M4.93 4.93l2.83 2.83" /><path d="M16.24 16.24l2.83 2.83" /><path d="M2 12h4" /><path d="M18 12h4" /><path d="M4.93 19.07l2.83-2.83" /><path d="M16.24 7.76l2.83-2.83" /></Icon>);

// Константы (взяты из твоего файла)
const ADMIN_UID = "fqU30jiK7rOobaur0XN2pVY4PMC2";
const PUBLIC_COLLECTION_NAME = "fanfic_gallery_albums";

const firebaseConfig = JSON.parse(window.__firebase_config || '{}');
let app = null, db = null, auth = null, configError = null;
try {
  if (firebaseConfig.apiKey) {
    app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth ? getAuth(app) : null;
  } else throw new Error("Firebase API key не определён");
} catch (e) {
  configError = { isCritical: true, name: "Ошибка Firebase", message: e.message };
  console.error(e);
}

const TARGET_ROW_HEIGHT = 300;
const GALLERY_GAP_PX = 2;
const MAX_ROW_HEIGHT_MULTIPLIER = 1.5;

// --- Image Modal (как в твоём исходнике) ---
function ImageModal({ image, onClose, onNext, onPrev, onSaveCaption, albumId, isAdmin }) {
  if (!image) return null;
  const [caption, setCaption] = useState(image.caption || '');
  const [isSaving, setIsSaving] = useState(false);
  const [isEditOpen, setIsEditOpen] = useState(false);

  useEffect(() => setCaption(image.caption || ''), [image && image.caption]);

  useEffect(()=>{
    const handleKey=(e)=>{
      if(e.key==='Escape') onClose();
      if(e.key==='ArrowRight') onNext();
      if(e.key==='ArrowLeft') onPrev();
    };
    document.addEventListener('keydown', handleKey);
    return ()=>document.removeEventListener('keydown', handleKey);
  },[onClose,onNext,onPrev]);

  const handleSave=async ()=>{
    if(!isAdmin) return;
    setIsSaving(true);
    await onSaveCaption(albumId, image.timestamp, caption);
    setIsSaving(false);
  };

  return (
    <div className="fixed inset-0 z-[60] bg-black bg-opacity-90 flex justify-center items-center" onClick={onClose}>
      <div className="absolute top-4 right-4 z-[70] flex space-x-2 p-2">
        {isAdmin && (
          <button onClick={(e)=>{e.stopPropagation(); setIsEditOpen(prev=>!prev);}} className={`p-2 text-white rounded-full ${isEditOpen ? 'bg-indigo-600' : 'bg-black bg-opacity-50'}`} title="Редактировать подпись">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
          </button>
        )}
        <button onClick={(e)=>{e.stopPropagation(); onClose();}} className="p-2 text-white bg-black bg-opacity-50 rounded-full">
          <X size={20}/>
        </button>
      </div>

      <div className="fixed-click-zone left group" onClick={(e)=>{e.stopPropagation(); onPrev();}} title="Prev">
        <button className="nav-arrow opacity-0 group-hover:opacity-100"><ChevronLeft size={36} /></button>
      </div>
      <div className="fixed-click-zone right group" onClick={(e)=>{e.stopPropagation(); onNext();}} title="Next">
        <button className="nav-arrow opacity-0 group-hover:opacity-100"><ChevronRight size={36} /></button>
      </div>

      <div className="w-full h-full flex justify-center items-center" onClick={(e)=>e.stopPropagation()}>
        <img src={image.url} alt={image.caption || 'Image'} className="max-w-full max-h-screen object-contain" onError={(e)=>{ e.target.onerror=null; e.target.src='https://placehold.co/800x600/CCCCCC/333333?text=Ошибка'; }}/>
      </div>

      <div className="absolute bottom-4 left-4 z-[70] max-w-sm" onClick={(e)=>e.stopPropagation()}>
        <div className="px-4 py-3 bg-transparent text-white">
          {image.caption ? <p className="text-sm font-medium text-with-shadow">{image.caption}</p> : <p className="text-sm text-with-shadow text-gray-300">Подпись отсутствует</p>}
        </div>

        {isAdmin && (
          <div className={`${isEditOpen ? 'block' : 'hidden'} bg-white p-4 rounded-xl shadow-2xl mt-2`}>
            <h3 className="text-lg font-bold mb-3">Редактировать подпись</h3>
            <textarea value={caption} onChange={(e)=>setCaption(e.target.value)} rows={3} className="w-full p-3 border rounded" maxLength={200}></textarea>
            <div className="mt-3">
              <button onClick={handleSave} disabled={isSaving} className="px-4 py-2 bg-indigo-600 text-white rounded">
                {isSaving ? 'Сохранение...' : 'Сохранить'}
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// --- Главный компонент приложения ---
function App() {
  // auth / data states
  const [authReady, setAuthReady] = useState(false);
  const [userId, setUserId] = useState(null);
  const [albums, setAlbums] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(configError || null);

  const [isAdmin, setIsAdmin] = useState(false);
  const [isDeleteMode, setIsDeleteMode] = useState(false);
  const [isReorderMode, setIsReorderMode] = useState(false);

  const [currentView, setCurrentView] = useState('home');
  const [selectedAlbum, setSelectedAlbum] = useState(null);

  const [enlargedImage, setEnlargedImage] = useState(null);

  // scroll saving
  const scrollPosition = useRef(0);
  const saveScrollPosition = useCallback(() => {
    scrollPosition.current = window.scrollY || document.documentElement.scrollTop || 0;
  }, []);

  // Уже было в твоём файле, но мы расширим поведение: восстанавливаем scroll
  useLayoutEffect(() => {
    // Если есть сохранённая позиция — пытаемся её восстановить после рендера
    if (typeof window === 'undefined') return;
    if (!scrollPosition.current) return;
    // Попробуем через requestAnimationFrame + setTimeout, чтобы дождаться DOM и ресурсов
    requestAnimationFrame(() => {
      setTimeout(() => {
        try {
          window.scrollTo({ top: scrollPosition.current, behavior: 'auto' });
        } catch(e) {
          window.scrollTo(0, scrollPosition.current);
        }
      }, 40);
    });
  }, [selectedAlbum, enlargedImage, isDeleteMode, isReorderMode]);

  // Дополнительный надёжный эффект: восстанавливаем позицию после обновления списка альбомов/данных
  useEffect(() => {
    if (!scrollPosition.current) return;
    // Если данные обновились (например, Firestore onSnapshot), то через небольшую задержку восстановим скролл
    const restore = () => {
      requestAnimationFrame(() => {
        setTimeout(() => {
          try { window.scrollTo({ top: scrollPosition.current, behavior: 'auto' }); }
          catch(e) { window.scrollTo(0, scrollPosition.current); }
        }, 60);
      });
    };
    restore();
  }, [albums]); // albums меняется при приходе данных из Firestore

  // Инициализация Firebase auth (как в оригинале)
  useEffect(() => {
    if (error && error.isCritical) { setAuthReady(true); setLoading(false); return; }
    if (!auth) { setAuthReady(true); setLoading(false); return; }

    // restore admin flag from localStorage
    const adminStatus = localStorage.getItem('isAdmin');
    if (adminStatus === 'true') setIsAdmin(true);

    const setup = async () => {
      try {
        if (window.__initial_auth_token) await signInWithCustomToken(auth, window.__initial_auth_token);
        else await signInAnonymously(auth);
      } catch(e) {
        console.error("Auth error", e);
        setError({ name: "Ошибка аутентификации", message: e.message || e.code });
      }
    };

    const unsub = onAuthStateChanged(auth, (user) => {
      if (user) setUserId(user.uid); else setUserId(null);
      setAuthReady(true);
    });

    setup();
    return () => unsub();
  }, [error]);

  // Listener на альбомы (public collection path аналогично твоему оригиналу)
  useEffect(() => {
    if (!db || !authReady) { if (authReady) setLoading(false); return; }
    setLoading(true);
    const collectionPath = `artifacts/${window.__app_id || 'default-app-id'}/public/data/${PUBLIC_COLLECTION_NAME}`;
    const q = query(collection(db, collectionPath));
    const unsub = onSnapshot(q, (snapshot) => {
      const fetched = [];
      snapshot.forEach(docSnap => {
        const data = docSnap.data();
        fetched.push({ id: docSnap.id, ...data, images: Array.isArray(data.images) ? data.images : [] });
      });
      fetched.sort((a,b)=> (b.createdAt?.seconds||0) - (a.createdAt?.seconds||0));
      setAlbums(fetched);
      setLoading(false);

      // Если выбран альбом, обновляем selectedAlbum ссылкой на новый объект из fetched
      setSelectedAlbum(prev => {
        if (!prev) return prev;
        const up = fetched.find(x=>x.id===prev.id);
        if (up) return up;
        // если альбом удалён — вернуть на home
        if (currentView === 'album') { setCurrentView('home'); return null; }
        return prev;
      });
    }, (err) => {
      console.error("Firestore listen error", err);
      setError({ name: "Ошибка получения данных", message: err.message });
      setLoading(false);
    });
    return () => unsub();
  }, [authReady, db]);

  // Навигация
  const handleGoHome = useCallback(()=>{
    saveScrollPosition();
    setSelectedAlbum(null);
    setCurrentView('home');
    setIsDeleteMode(false);
    setIsReorderMode(false);
  }, [saveScrollPosition]);

  const handleOpenAlbum = useCallback((album)=>{
    saveScrollPosition();
    setSelectedAlbum(album);
    setCurrentView('album');
    setIsDeleteMode(false);
    setIsReorderMode(false);
  }, [saveScrollPosition]);

  // Navigation in modal
  const handleNavigation = useCallback((direction)=>{
    if (!enlargedImage || !selectedAlbum) return;
    const all = selectedAlbum.images.filter(i=>i.type!=='divider');
    if (all.length===0) return;
    const idx = all.findIndex(img=>img.timestamp===enlargedImage.timestamp);
    if (idx===-1) return;
    const nextIdx = direction==='next' ? (idx+1)%all.length : (idx-1+all.length)%all.length;
    setEnlargedImage(all[nextIdx]);
  }, [enlargedImage, selectedAlbum]);

  const handleNextImage = useCallback(()=>handleNavigation('next'), [handleNavigation]);
  const handlePrevImage = useCallback(()=>handleNavigation('prev'), [handleNavigation]);

  // CRUD-like handlers (we add saveScrollPosition where appropriate)
  const updatePhotoCaption = async (albumId, photoTimestamp, newCaption) => {
    if (!isAdmin) { alertUser('Ошибка доступа','Только админ'); return; }
    if (!db || !albumId) { alertUser('Ошибка','Нет DB'); return; }
    try {
      const collectionPath = `artifacts/${window.__app_id}/public/data/${PUBLIC_COLLECTION_NAME}`;
      const albumRef = doc(db, collectionPath, albumId);
      const current = albums.find(a=>a.id===albumId);
      if (!current) return;
      const updated = current.images.map(item => item.timestamp===photoTimestamp && item.type!=='divider' ? {...item, caption:newCaption.trim()} : item);
      await updateDoc(albumRef, { images: updated });
      setEnlargedImage(prev => prev && prev.timestamp===photoTimestamp ? {...prev, caption: newCaption.trim()} : prev);
    } catch(e){ console.error(e); alertUser('Ошибка','Не удалось сохранить подпись'); }
  };

  const deletePhoto = async (albumId, itemToDelete) => {
    saveScrollPosition(); // важно — сохраняем перед изменением, чтобы восстановление сработало корректно
    if (!isAdmin) { alertUser('Ошибка доступа','Только админ'); return; }
    if (!db || !albumId) { alertUser('Критично','Нет DB'); return; }
    try {
      const collectionPath = `artifacts/${window.__app_id}/public/data/${PUBLIC_COLLECTION_NAME}`;
      const albumRef = doc(db, collectionPath, albumId);
      const current = albums.find(a=>a.id===albumId);
      if (!current) return;
      const updated = current.images.filter(item => item.timestamp !== itemToDelete.timestamp);
      await updateDoc(albumRef, { images: updated });
      // если текущий увеличенный — закрываем
      if (enlargedImage && enlargedImage.timestamp === itemToDelete.timestamp) {
        saveScrollPosition();
        setEnlargedImage(null);
      }
    } catch(e) { console.error(e); alertUser('Ошибка','Не удалось удалить'); }
  };

  // Drag&Drop reorder (сохранение позиции перед операцией)
  const dragItemUniqueId = useRef(null);
  const dragOverItemUniqueId = useRef(null);

  const handleDragStart = useCallback((e, uniqueId) => {
    if (!isReorderMode || !isAdmin) return;
    dragItemUniqueId.current = uniqueId;
    e.dataTransfer.effectAllowed = "move";
    if (e.dataTransfer.setDragImage) {
      try {
        const el = e.target.closest('div').querySelector('img') || e.target;
        if (el) e.dataTransfer.setDragImage(el, 10, 10);
      } catch(e){}
    }
  }, [isReorderMode, isAdmin]);

  const handleDragEnter = useCallback((e, uniqueId) => {
    if (!isReorderMode || !isAdmin) return;
    dragOverItemUniqueId.current = uniqueId;
  }, [isReorderMode, isAdmin]);

  const handleDragOver = useCallback((e) => {
    if (!isReorderMode || !isAdmin) return;
    e.preventDefault();
  }, [isReorderMode, isAdmin]);

  const handleDrop = useCallback(async (e) => {
    // Сохраняем скролл до обновления
    saveScrollPosition();
    if (!isAdmin) { alertUser('Ошибка доступа','Только админ'); dragItemUniqueId.current = null; dragOverItemUniqueId.current = null; return; }
    if (!isReorderMode) return;
    if (!selectedAlbum || !db) { alertUser('Критично','Нет альбома или DB'); dragItemUniqueId.current = null; dragOverItemUniqueId.current = null; return; }

    const draggedId = dragItemUniqueId.current;
    const targetId = dragOverItemUniqueId.current;
    if (draggedId===null || targetId===null || draggedId===targetId) { dragItemUniqueId.current = null; dragOverItemUniqueId.current = null; return; }

    const collectionPath = `artifacts/${window.__app_id}/public/data/${PUBLIC_COLLECTION_NAME}`;
    const albumRef = doc(db, collectionPath, selectedAlbum.id);
    const list = [...selectedAlbum.images];
    const draggedIndex = list.findIndex(item=>item.timestamp===draggedId);
    const targetIndex = list.findIndex(item=>item.timestamp===targetId);
    if (draggedIndex===-1 || targetIndex===-1) { dragItemUniqueId.current = null; dragOverItemUniqueId.current = null; return; }
    const [itemToMove] = list.splice(draggedIndex,1);
    list.splice(targetIndex,0,itemToMove);
    try {
      await updateDoc(albumRef, { images: list });
    } catch(e) { console.error(e); alertUser('Ошибка','Не удалось сохранить порядок'); }
    dragItemUniqueId.current = null;
    dragOverItemUniqueId.current = null;
  }, [isReorderMode, isAdmin, selectedAlbum, db, saveScrollPosition]);

  // Добавление разделителя (как в оригинале)
  const addDivider = async (albumId, text) => {
    if (!isAdmin) { alertUser('Ошибка доступа','Только админ'); return; }
    if (!db || !albumId || !text.trim()) { alertUser('Критично','Нет данных'); return; }
    try {
      const collectionPath = `artifacts/${window.__app_id}/public/data/${PUBLIC_COLLECTION_NAME}`;
      const albumRef = doc(db, collectionPath, albumId);
      const newDivider = { type: 'divider', timestamp: Date.now(), text: text.trim() };
      await updateDoc(albumRef, { images: arrayUnion(newDivider) });
    } catch(e) { console.error(e); alertUser('Ошибка','Не удалось добавить разделитель'); }
  };

  // Добавление фото по ссылке
  const addPhotoLink = async (albumId, url, aspectRatio=1.0) => {
    if (!isAdmin) { alertUser('Ошибка доступа','Только админ'); return; }
    if (!db || !albumId || !url.trim()) { alertUser('Критично','Нет данных'); return; }
    try {
      const collectionPath = `artifacts/${window.__app_id}/public/data/${PUBLIC_COLLECTION_NAME}`;
      const albumRef = doc(db, collectionPath, albumId);
      const newImage = { url: url.trim(), type: 'photo', timestamp: Date.now(), aspectRatio: parseFloat(aspectRatio) || 1.0, caption: '' };
      await updateDoc(albumRef, { images: arrayUnion(newImage) });
    } catch(e) { console.error(e); alertUser('Ошибка','Не удалось добавить фото'); }
  };

  // Создание альбома
  const createNewAlbum = async (name) => {
    if (!isAdmin) { alertUser('Ошибка доступа','Только админ'); return; }
    if (!db || !name.trim()) { alertUser('Критично','Нет данных'); return; }
    try {
      const collectionPath = `artifacts/${window.__app_id}/public/data/${PUBLIC_COLLECTION_NAME}`;
      await addDoc(collection(db, collectionPath), { name: name.trim(), createdAt: serverTimestamp(), images: [], previewUrl: null });
    } catch(e) { console.error(e); alertUser('Ошибка','Не удалось создать альбом'); }
  };

  // Прочие UI-утилиты
  const alertUser = (title, message) => {
    console.warn(`${title}: ${message}`);
    // лёгкое визуальное уведомление
    const el = document.createElement('div');
    el.innerHTML = `<div style="position:fixed;left:50%;top:15%;transform:translateX(-50%);background:white;padding:12px 18px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.12);z-index:9999;border:2px solid #ef4444;"><strong style="display:block;margin-bottom:6px;color:#ef4444;">${title}</strong><div style="color:#111">${message}</div><div style="text-align:right;margin-top:8px;"><button style="background:#4f46e5;color:#fff;padding:6px 10px;border-radius:6px;border:none;">OK</button></div></div>`;
    const node = el.firstChild;
    node.querySelector('button').onclick = ()=>node.remove();
    document.body.appendChild(node);
  };

  // Helpers для макета justified gallery (сокращённо взято из твоего файла)
  const AlbumPhotoView = () => {
    if (!selectedAlbum) return <HomeView />;
    const albumRef = useRef(null);
    const [containerWidth, setContainerWidth] = useState(0);
    useEffect(() => {
      const upd = ()=>{ if (albumRef.current) setContainerWidth(albumRef.current.clientWidth); };
      upd();
      const ro = new ResizeObserver(upd);
      if (albumRef.current) ro.observe(albumRef.current);
      return ()=>ro.disconnect();
    }, []);

    const allContent = selectedAlbum.images || [];

    const justifiedRows = useMemo(()=>{
      if (containerWidth <= 0) return [];
      const rows = [];
      let currentRow = [], currentAspect = 0;
      const gapWidth = (count)=> (count-1)*GALLERY_GAP_PX;
      const finalize = (row, isLast=false)=>{
        if (row.length===0) return;
        const rowGap = gapWidth(row.length);
        const rowCW = containerWidth - rowGap;
        const totalAspect = row.reduce((s,i)=>s+(i.aspectRatio||1),0);
        let finalH = rowCW/totalAspect;
        if (!isLast) {
          const maxH = TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER;
          if (finalH > maxH) finalH = maxH;
        } else {
          if (finalH > TARGET_ROW_HEIGHT*1.2) finalH = TARGET_ROW_HEIGHT;
        }
        rows.push({ type:'photoRow', content: row.map(img=>({ ...img, height: finalH, width: (img.aspectRatio||1)*finalH }))});
      };

      for (const item of allContent) {
        if (item.type === 'divider') {
          if (currentRow.length>0) { finalize(currentRow); currentRow = []; currentAspect = 0; }
          rows.push({ type:'dividerRow', content: item, uniqueId: item.timestamp});
        } else if (item.url && item.aspectRatio>0) {
          const potentialAspect = currentAspect + item.aspectRatio;
          const rowCount = currentRow.length+1;
          const potentialRowHeight = (containerWidth - gapWidth(rowCount))/potentialAspect;
          const shouldStartNew = currentRow.length>0 && potentialRowHeight < TARGET_ROW_HEIGHT*0.9;
          if (shouldStartNew) { finalize(currentRow); currentRow = [item]; currentAspect = item.aspectRatio; }
          else { currentRow.push(item); currentAspect = potentialAspect; }
        }
      }
      if (currentRow.length>0) finalize(currentRow, true);
      return rows;
    }, [allContent, containerWidth]);

    const isDraggingCurrent = (unique) => isReorderMode && dragItemUniqueId.current === unique;
    const isDragOverTarget = (unique) => isReorderMode && dragOverItemUniqueId.current === unique && dragItemUniqueId.current !== unique;

    return (
      <div className="py-6 md:py-10 pt-4 md:pt-6">
        <div ref={albumRef} className="w-full" onDrop={isReorderMode && isAdmin ? handleDrop : undefined} onDragOver={isReorderMode && isAdmin ? handleDragOver : undefined}>
          {containerWidth === 0 && allContent.length > 0 && (
            <div className="flex items-center justify-center py-6"><Loader className="animate-spin" /><span className="ml-3">Расчёт макета...</span></div>
          )}

          {(containerWidth>0 && justifiedRows.length>0) && justifiedRows.map((rowWrapper, rIdx) => {
            if (rowWrapper.type === 'dividerRow') {
              const divider = rowWrapper.content;
              return (
                <div key={divider.timestamp} className={`w-full my-8 flex items-center justify-center relative ${isReorderMode ? 'cursor-grab py-2' : ''} ${isDraggingCurrent(divider.timestamp) ? 'opacity-50 border-2 border-indigo-500 scale-[0.98]' : ''} ${isDragOverTarget(divider.timestamp) ? 'border-2 border-dashed border-green-500' : ''}`} draggable={isReorderMode && isAdmin} onDragStart={isReorderMode && isAdmin ? (e)=>handleDragStart(e, divider.timestamp) : undefined} onDragEnter={isReorderMode && isAdmin ? (e)=>handleDragEnter(e, divider.timestamp) : undefined}>
                  <div className="w-full h-px bg-gray-300 mx-4 hidden sm:block"></div>
                  <h2 className="text-2xl font-extrabold text-gray-800 px-4 py-2 border-b-2 border-indigo-600 inline-block text-center whitespace-nowrap">{divider.text}</h2>
                  <div className="w-full h-px bg-gray-300 mx-4 hidden sm:block"></div>
                  {isDeleteMode && isAdmin && (<button onClick={(e)=>{ e.stopPropagation(); deletePhoto(selectedAlbum.id, divider);}} className="absolute top-1/2 right-2 transform -translate-y-1/2 bg-red-600 text-white p-1.5 rounded-full z-20"><Trash2/></button>)}
                </div>
              );
            }

            const row = rowWrapper.content;
            return (
              <div key={rIdx} className="flex overflow-hidden" style={{ marginBottom: `${GALLERY_GAP_PX}px` }}>
                {row.map((image, iIdx) => {
                  const unique = image.timestamp;
                  return (
                    <div key={unique} onClick={!isDeleteMode && !isReorderMode ? ()=>setEnlargedImage(image) : undefined}
                      draggable={isReorderMode && isAdmin}
                      onDragStart={isReorderMode && isAdmin ? (e)=>handleDragStart(e, unique) : undefined}
                      onDragEnter={isReorderMode && isAdmin ? (e)=>handleDragEnter(e, unique) : undefined}
                      className={`cursor-pointer relative overflow-hidden bg-gray-200 transition duration-150 shadow-md ${isReorderMode && isAdmin ? 'cursor-grab active:cursor-grabbing' : 'hover:opacity-90'} ${isDraggingCurrent(unique) ? 'opacity-50 border-4 border-indigo-500 scale-95' : ''} ${isDragOverTarget(unique) ? 'border-4 border-dashed border-green-500' : ''}`}
                      style={{ height: `${image.height}px`, width: `${image.width}px`, marginRight: iIdx < row.length - 1 ? `${GALLERY_GAP_PX}px` : '0' }}>
                      <img src={image.url} alt={image.caption || `Фото ${iIdx+1}`} className="w-full h-full object-cover" onError={(e)=>{ e.target.onerror=null; e.target.src='https://placehold.co/400x400/CCCCCC/333333?text=URL+недоступен'; }}/>
                      {isDeleteMode && isAdmin && (<button onClick={(e)=>{ e.stopPropagation(); deletePhoto(selectedAlbum.id, image); }} className="absolute top-2 right-2 bg-red-600 text-white p-1.5 rounded z-20"><Trash2/></button>)}
                      {isReorderMode && isAdmin && (<div className="absolute top-1/2 left-2 transform -translate-y-1/2 bg-black/50 text-white p-1 rounded opacity-0 group-hover:opacity-100"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2"><circle cx="9" cy="12" r="1"/><circle cx="9" cy="5" r="1"/><circle cx="9" cy="19" r="1"/><circle cx="15" cy="12" r="1"/><circle cx="15" cy="5" r="1"/><circle cx="15" cy="19" r="1"/></svg></div>)}
                    </div>
                  );
                })}
              </div>
            );
          })}
          {allContent.length === 0 && (<div className="mx-4 sm:mx-6 lg:mx-8 text-center py-20 bg-gray-50 rounded-xl mt-8 border border-dashed border-gray-300"><ImageIcon className="w-12 h-12 text-gray-400 mx-auto"/><h3 className="mt-2 text-lg font-medium text-gray-900">Этот альбом пуст</h3>{isAdmin ? <p className="mt-1 text-sm">Добавьте фото или разделитель.</p> : <p className="mt-1 text-sm">Админ добавит контент.</p>}</div>)}
        </div>
      </div>
    );
  };

  const HomeView = () => (
    <div className="px-4 sm:px-6 lg:px-8 py-8">
      <h2 className="text-3xl font-extrabold text-gray-900 mb-8 border-b pb-2">Все альбомы</h2>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {albums.length === 0 ? <div className="col-span-full text-center py-20 bg-white rounded-xl border border-dashed border-gray-300">Альбомы не найдены</div> : albums.map(alb => (
          <div key={alb.id} className="bg-white rounded-xl shadow-lg overflow-hidden cursor-pointer" onClick={()=>handleOpenAlbum(alb)}>
            <div className="w-full h-48 bg-gray-200 flex items-center justify-center relative">
              {alb.images && alb.images.find(it=>it.type!=='divider' && it.url) ? <img src={alb.images.find(it=>it.type!=='divider' && it.url).url} alt={alb.name} className="w-full h-full object-cover"/> : <ImageIcon className="w-1/3 h-1/3 text-gray-500"/>}
            </div>
            <div className="p-4">
              <h3 className="font-semibold text-lg text-gray-800 truncate">{alb.name}</h3>
              <p className="text-sm text-gray-500 mt-1">{ (alb.images||[]).filter(i=>i.type!=='divider').length } фото</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );

  // Верхняя панель
  const TopBar = () => (
    <div className="bg-white shadow sticky top-0 z-40">
      <div className="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <h1 className="text-xl font-bold">Leon H-Arts</h1>
          <nav className="text-sm text-gray-600">
            <button onClick={handleGoHome} className="mr-3 hover:underline">Главная</button>
            <span>|</span>
            <button onClick={()=>{ saveScrollPosition(); setIsDeleteMode(prev=>!prev); setIsReorderMode(false); }} className={`ml-3 ${isDeleteMode ? 'text-red-600' : ''}`}>{isDeleteMode ? 'Режим удаления (ON)' : 'Режим удаления'}</button>
            <button onClick={()=>{ saveScrollPosition(); setIsReorderMode(prev=>!prev); setIsDeleteMode(false); }} className={`ml-3 ${isReorderMode ? 'text-indigo-600' : ''}`}>{isReorderMode ? 'Переупорядочивание (ON)' : 'Переупорядочивание'}</button>
          </nav>
        </div>

        <div className="flex items-center space-x-3">
          {isAdmin ? <button onClick={()=>{ setIsAdmin(false); localStorage.removeItem('isAdmin'); }} className="px-3 py-1 bg-gray-100 rounded">Выйти (Admin)</button> : <button onClick={()=>{ alertUser('Вход','Открой модал для входа (в демо отключено)'); }} className="px-3 py-1 bg-indigo-600 text-white rounded">Войти</button>}
          <button onClick={()=>{ saveScrollPosition(); setIsAddAlbumModalOpen(true); }} className="px-3 py-1 bg-indigo-600 text-white rounded">Создать альбом</button>
        </div>
      </div>
    </div>
  );

  // Модалки (минимальны: добавление альбома / фото) — для демонстрации фикса прокрутки
  const [isAddAlbumModalOpen, setIsAddAlbumModalOpen] = useState(false);
  const [isAddPhotoModalOpen, setIsAddPhotoModalOpen] = useState(false);
  const [isAddDividerModalOpen, setIsAddDividerModalOpen] = useState(false);
  const [albumToRename, setAlbumToRename] = useState(null);

  const RenameAlbumModal = () => {
    const [newName, setNewName] = useState(albumToRename?.name || '');
    useEffect(()=> setNewName(albumToRename?.name || ''), [albumToRename]);
    const [isSaving, setIsSaving] = useState(false);
    const handleSubmit = async (e)=> {
      e.preventDefault();
      if (!newName.trim() || !albumToRename) return;
      setIsSaving(true);
      await renameAlbum(albumToRename.id, newName);
      setIsSaving(false);
    };
    return null; // опустил UI для краткости — ты можешь вернуть свой полноценный модал
  };

  // Переименование альбома (реализовано в оригинале)
  const renameAlbum = async (albumId, newName)=> {
    if (!isAdmin) { alertUser('Ошибка доступа','Только админ'); return false; }
    if (!db || !albumId) { alertUser('Критично','Нет DB'); return false; }
    try {
      const collectionPath = `artifacts/${window.__app_id}/public/data/${PUBLIC_COLLECTION_NAME}`;
      const albumRef = doc(db, collectionPath, albumId);
      await updateDoc(albumRef, { name: newName.trim() });
      return true;
    } catch(e) { console.error(e); alertUser('Ошибка','Не удалось переименовать'); return false; }
  };

  // Add album modal minimal UI
  const AddAlbumModal = () => {
    const [name, setName] = useState('');
    const submit = (e)=>{ e.preventDefault(); if (name.trim()) createNewAlbum(name); setIsAddAlbumModalOpen(false); };
    if (!isAddAlbumModalOpen) return null;
    return (
      <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center" onClick={()=>setIsAddAlbumModalOpen(false)}>
        <div className="bg-white rounded p-6 w-full max-w-md" onClick={(e)=>e.stopPropagation()}>
          <h3 className="font-bold mb-3">Создать альбом</h3>
          <form onSubmit={submit}>
            <input className="w-full p-2 border rounded mb-3" placeholder="Название альбома" value={name} onChange={(e)=>setName(e.target.value)} />
            <div className="flex justify-end space-x-2">
              <button type="button" onClick={()=>setIsAddAlbumModalOpen(false)} className="px-3 py-1 border rounded">Отмена</button>
              <button type="submit" className="px-3 py-1 bg-indigo-600 text-white rounded">Создать</button>
            </div>
          </form>
        </div>
      </div>
    );
  };

  // Add photo modal (минимально)
  const AddPhotoModal = () => {
    const [url, setUrl] = useState('');
    const [ratio, setRatio] = useState('1.0');
    const [selAlb, setSelAlb] = useState(selectedAlbum?.id || (albums[0] && albums[0].id) || '');
    useEffect(()=> { if (albums.length>0 && !selAlb) setSelAlb(albums[0].id); }, [albums]);
    if (!isAddPhotoModalOpen) return null;
    const submit = (e)=>{ e.preventDefault(); if (selAlb && url.trim()) { addPhotoLink(selAlb, url, parseFloat(ratio)||1.0); setIsAddPhotoModalOpen(false); } };
    return (
      <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center" onClick={()=>setIsAddPhotoModalOpen(false)}>
        <div className="bg-white rounded p-6 w-full max-w-md" onClick={(e)=>e.stopPropagation()}>
          <h3 className="font-bold mb-3">Добавить фото по ссылке</h3>
          <form onSubmit={submit}>
            <input className="w-full p-2 border rounded mb-2" placeholder="https://..." value={url} onChange={(e)=>setUrl(e.target.value)} />
            <input className="w-full p-2 border rounded mb-2" placeholder="Соотношение (1.0)" value={ratio} onChange={(e)=>setRatio(e.target.value)} />
            <select className="w-full p-2 border rounded mb-3" value={selAlb} onChange={(e)=>setSelAlb(e.target.value)}>
              {albums.map(a=> <option key={a.id} value={a.id}>{a.name}</option>)}
            </select>
            <div className="flex justify-end space-x-2">
              <button type="button" onClick={()=>setIsAddPhotoModalOpen(false)} className="px-3 py-1 border rounded">Отмена</button>
              <button type="submit" className="px-3 py-1 bg-indigo-600 text-white rounded">Добавить</button>
            </div>
          </form>
        </div>
      </div>
    );
  };

  // Пока для простоты рендера — поверх возвращаем TopBar + Home/Album
  return (
    <div>
      <TopBar />
      <main className="max-w-6xl mx-auto">
        {loading && <div className="p-8 text-center">Загрузка...</div>}
        {!loading && (currentView === 'home' ? <HomeView /> : <AlbumPhotoView />)}
      </main>

      {/* Модалки */}
      <AddAlbumModal />
      <AddPhotoModal />
      {enlargedImage && <ImageModal image={enlargedImage} onClose={() => { saveScrollPosition(); setEnlargedImage(null); }} onNext={handleNextImage} onPrev={handlePrevImage} onSaveCaption={updatePhotoCaption} albumId={selectedAlbum?.id} isAdmin={isAdmin} />}

    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
