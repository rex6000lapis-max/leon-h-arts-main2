<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leon H-Arts</title>
<!-- ФАВИКОНЫ: Сгенерированы через Favicon.io -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="shortcut icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
    
    <!-- 1. Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React, ReactDOM, Babel CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 3. Firebase CDNs -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { 
        getAuth, 
        signInAnonymously, 
        signInWithCustomToken, 
        onAuthStateChanged, 
        signInWithEmailAndPassword, 
        signOut 
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { 
        getFirestore, 
        doc, 
        onSnapshot, 
        collection, 
        query, 
        addDoc, 
        updateDoc,
        deleteDoc,
        arrayUnion, 
        serverTimestamp,
        writeBatch 
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // --- Экспортируем всё в window, чтобы React-скрипт мог обращаться ---
    window.initializeApp = initializeApp;
    window.getAuth = getAuth;
    window.signInAnonymously = signInAnonymously;
    window.signInWithCustomToken = signInWithCustomToken;
    window.onAuthStateChanged = onAuthStateChanged;
    window.signInWithEmailAndPassword = signInWithEmailAndPassword;
    window.signOut = signOut;
    window.getFirestore = getFirestore;
    window.doc = doc;
    window.onSnapshot = onSnapshot;
    window.collection = collection;
    window.query = query;
    window.addDoc = addDoc;
    window.updateDoc = updateDoc;
    window.deleteDoc = deleteDoc;
    window.arrayUnion = arrayUnion;
    window.serverTimestamp = serverTimestamp;
    window.writeBatch = writeBatch;

    // --- Глобальные переменные для оффлайн-режима ---
    if (typeof window.__app_id === 'undefined') window.__app_id = 'default-app-id';
    if (typeof window.__initial_auth_token === 'undefined') window.__initial_auth_token = null;
    if (typeof window.__firebase_config === 'undefined') {
        window.__firebase_config = JSON.stringify({
            apiKey: "AIzaSyBpThMaS36IkmAqUrvk9WpWi0AhOhndhU8",
            authDomain: "leon-h-arts-6b69b.firebaseapp.com",
            projectId: "leon-h-arts-6b69b",
            storageBucket: "leon-h-arts-6b69b.firebasestorage.app",
            messagingSenderId: "162244900947",
            appId: "1:162244900947:web:0d265bc4fe5639380ceea6"
        });
    }
</script>
    
    <style>
        /* Общие стили для фона и шрифта */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        /* Устранение проблем с прокруткой и переполнением */
        .min-h-screen { min-height: 100vh; }
        
        /* Стили для модала изображения */
        .text-with-shadow {
          color: white;
          text-shadow: 
            -1px -1px 0 #000,  
             1px -1px 0 #000,
            -1px 1px 0 #000,
             1px 1px 0 #000,
             0 0 10px rgba(0, 0, 0, 1);
        }

        .fixed-click-zone {
          position: fixed; 
          top: 50%;
          transform: translateY(-50%); 
          width: 20%; 
          height: 50%; 
          z-index: 65; 
          cursor: pointer;
          display: flex;
          align-items: center;
          -webkit-tap-highlight-color: transparent; 
        }
        .fixed-click-zone.left {
          left: 0;
          justify-content: flex-start;
        }
        .fixed-click-zone.right {
          right: 0;
          justify-content: flex-end;
        }
        
        .nav-arrow {
          color: white;
          padding: 0;
          cursor: pointer;
          filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.9));
        }
        
        .fixed-click-zone.left .nav-arrow {
          padding-left: 0.5rem; 
        }
        .fixed-click-zone.right .nav-arrow {
          padding-right: 0.5rem; 
        }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in-up { animation: fadeInUp 0.3s ease-out; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Получаем глобальные переменные, предоставленные Canvas
        const {useState, useEffect, useCallback, useMemo, useRef} = React;
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, doc, onSnapshot, collection, query, addDoc, updateDoc, deleteDoc, arrayUnion, serverTimestamp, writeBatch } = window;

        // --- Встроенные React SVG компоненты (замена lucide-react) ---
        const Icon = ({ children, size = 24, className = '', ...props }) => (
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width={size}
                height={size}
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className={`lucide ${className}`}
                {...props}
            >
                {children}
            </svg>
        );

        const Plus = (props) => (
            <Icon {...props}><line x1="12" x2="12" y1="5" y2="19" /><line x1="5" x2="19" y1="12" y2="12" /></Icon>
        );
        const X = (props) => (
            <Icon {...props}><line x1="18" x2="6" y1="6" y2="18" /><line x1="6" x2="18" y1="6" y2="18" /></Icon>
        );
        const ImageIcon = (props) => (
            <Icon {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" /></Icon>
        );
        const Loader = (props) => (
            <Icon {...props}><path d="M12 2v4" /><path d="M12 18v4" /><path d="M4.93 4.93l2.83 2.83" /><path d="M16.24 16.24l2.83 2.83" /><path d="M2 12h4" /><path d="M18 12h4" /><path d="M4.93 19.07l2.83-2.83" /><path d="M16.24 7.76l2.83-2.83" /></Icon>
        );
        const Trash2 = (props) => (
            <Icon {...props}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></Icon>
        );
        const ArrowUpDown = (props) => (
            <Icon {...props}><path d="m21 16-4 4-4-4" /><path d="M17 20V4" /><path d="m3 8 4-4 4 4" /><path d="M7 4v16" /></Icon>
        );
        const GripVertical = (props) => (
            <Icon {...props}><circle cx="9" cy="12" r="1" /><circle cx="9" cy="5" r="1" /><circle cx="9" cy="19" r="1" /><circle cx="15" cy="12" r="1" /><circle cx="15" cy="5" r="1" /><circle cx="15" cy="19" r="1" /></Icon>
        );
        const Save = (props) => (
            <Icon {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><path d="M17 21v-8H7v8" /><path d="M7 3v5h8" /></Icon>
        );
        const Pencil = (props) => (
            <Icon {...props}><path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" /></Icon>
        );
        const ChevronLeft = (props) => (
            <Icon {...props}><path d="m15 18-6-6 6-6" /></Icon>
        );
        const ChevronRight = (props) => (
            <Icon {...props}><path d="m9 18 6-6-6-6" /></Icon>
        );
        const Key = (props) => (
            <Icon {...props}><path d="m15.5 13.5 1.7-1.7a2.85 2.85 0 1 1 4 4L19 18l-2 2-4-4 1.5-1.5z" /><path d="M11 20 5 14v-2.5l2.5-2.5h1.7" /><path d="m10 12-1-1" /></Icon>
        );
        const Edit = (props) => (
            <Icon {...props}><path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" /></Icon>
        );
        const AlertTriangle = (props) => (
            <Icon {...props}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" /><line x1="12" x2="12" y1="9" y2="13" /><line x1="12" x2="12" y1="17" y2="17" /></Icon>
        );
        const Eye = (props) => (
            <Icon {...props}><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" /><circle cx="12" cy="12" r="3" /></Icon>
        );
        const EyeOff = (props) => (
            <Icon {...props}><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" /><line x1="1" y1="1" x2="23" y2="23" /></Icon>
        );

        // --- КОНСТАНТЫ И НАСТРОЙКИ ---
        const ADMIN_UID = "fqU30jiK7rOobaur0XN2pVY4PMC2";  
        const PUBLIC_COLLECTION_NAME = "fanfic_gallery_albums"; 

        // Использование глобальных переменных Canvas
        const firebaseConfig = JSON.parse(window.__firebase_config);
        const appId = window.__app_id;
        const initialAuthToken = window.__initial_auth_token;

        let app = null;
        let db = null;
        let auth = null;
        let configError = null;

        try {
            if (firebaseConfig.apiKey) {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } else {
                throw new Error("API Key Firebase не определен.");
            }
        } catch (e) {
            configError = {
                isCritical: true,
                name: "Ошибка Конфигурации Firebase",
                message: `Не удалось загрузить конфигурацию Firebase. ${e.message}`
            };
        }

        const TARGET_ROW_HEIGHT = 300; 
        const GALLERY_GAP_PX = 2; 
        const MAX_ROW_HEIGHT_MULTIPLIER = 1.5;

        // --- КОМПОНЕНТ: Модальное окно для увеличенного изображения ---
        const ImageModal = ({ image, onClose, onSaveCaption, albumId, onNext, onPrev, isAdmin }) => {
            if (!image || image.type === 'divider') return null;

            const [caption, setCaption] = useState(image.caption || '');
            const [isSaving, setIsSaving] = useState(false);
            const [isEditPanelOpen, setIsEditPanelOpen] = useState(false); 
            
            useEffect(() => {
                setCaption(image.caption || '');
            }, [image.caption]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        onClose();
                    } else if (e.key === 'ArrowRight') {
                        onNext();
                    } else if (e.key === 'ArrowLeft') {
                        onPrev();
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => {
                    document.removeEventListener('keydown', handleKeyDown);
                };
            }, [onClose, onNext, onPrev]);

            const handleSave = async () => {
                if (!isAdmin) {
                     console.warn("Попытка сохранения без прав администратора.");
                     return;
                }
                setIsSaving(true);
                await onSaveCaption(albumId, image.timestamp, caption);
                setIsSaving(false);
            };

            return (
                <div 
                    className="fixed inset-0 z-[60] bg-black flex justify-center items-center transition-opacity"
                    onClick={onClose}
                >
                    {/* --- Контейнер для кнопок X и i (вверху справа) --- */}
                    <div className="absolute top-4 right-4 z-[70] flex space-x-2 p-2">
                        {isAdmin && (
                            <button
                                onClick={(e) => { e.stopPropagation(); setIsEditPanelOpen(prev => !prev); }}
                                className={`p-2 text-white transition rounded-full shadow-lg ${
                                    isEditPanelOpen ? 'bg-indigo-600' : 'bg-black bg-opacity-50 hover:bg-opacity-70'
                                }`}
                                title="Информация и подпись (Только Админ)"
                                aria-label="Открыть/Закрыть панель информации"
                            >
                                <Pencil size={24} />
                            </button>
                        )}
                        <button 
                            onClick={onClose} 
                            className="p-2 text-white hover:bg-opacity-70 transition rounded-full bg-black bg-opacity-50"
                            aria-label="Закрыть"
                        >
                            <X size={28} />
                        </button>
                    </div>
                    
                    {/* --- Левая/Правая навигация --- */}
                    <div 
                        className="fixed-click-zone left group"
                        onClick={(e) => { e.stopPropagation(); onPrev(); }}
                        title="Предыдущее фото (Стрелка влево)"
                    >
                        <button className="nav-arrow opacity-0 group-hover:opacity-100 transition-opacity">
                            <ChevronLeft size={40} className="w-10 h-10 md:w-12 md:h-12" />
                        </button>
                    </div>
                    <div 
                        className="fixed-click-zone right group"
                        onClick={(e) => { e.stopPropagation(); onNext(); }}
                        title="Следующее фото (Стрелка вправо)"
                    >
                        <button className="nav-arrow opacity-0 group-hover:opacity-100 transition-opacity">
                            <ChevronRight size={40} className="w-10 h-10 md:w-12 md:h-12" />
                        </button>
                    </div>
                    
                    {/* Контейнер изображения */}
                    <div 
                        className="w-full h-full flex justify-center items-center" 
                        onClick={(e) => e.stopPropagation()} 
                    >
                        <img 
                            src={image.url} 
                            alt={image.caption || "Увеличенное фото"} 
                            className="max-w-full max-h-screen object-contain" 
                            onError={(e) => { 
                                e.target.onerror = null; 
                                e.target.src = "https://placehold.co/800x600/CCCCCC/333333?text=Ошибка+загрузки"; 
                                e.target.className = "max-w-full max-h-[70vh] object-contain p-4"; 
                            }}
                        />
                    </div>
                    
                    {/* --- Контейнер подписи и редактирования --- */}
                    <div 
                        className="absolute bottom-4 left-4 z-[70] max-w-sm w-full sm:w-auto" 
                        onClick={(e) => e.stopPropagation()} 
                    >
                        <div 
                            className="px-4 py-3 sm:px-6 sm:py-4 bg-transparent text-white"
                        >
                            {image.caption ? (
                                <p className="text-sm font-medium text-with-shadow">{image.caption}</p>
                            ) : (
                                <p className="text-sm font-light text-with-shadow text-gray-300">Подпись отсутствует</p>
                            )}
                        </div>

                        {/* Панель редактирования подписи (Только для Админа) */}
                        {isAdmin && (
                            <div 
                                className={`bg-white p-4 sm:p-6 rounded-xl shadow-2xl transition-all duration-300 ease-in-out mt-2 ${
                                    isEditPanelOpen ? 'block' : 'hidden'
                                }`}
                            >
                                <h3 className="text-lg font-bold text-gray-800 mb-3">Редактировать подпись</h3>
                                <textarea
                                    value={caption}
                                    onChange={(e) => setCaption(e.target.value)}
                                    placeholder="Введите подпись, например, 'Главный персонаж Аниме X'"
                                    className="w-full flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
                                    maxLength={200}
                                    rows={3}
                                />
                                <button 
                                    onClick={handleSave}
                                    disabled={isSaving}
                                    className="flex items-center px-4 py-3 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition disabled:bg-indigo-400 shadow-md"
                                >
                                    {isSaving ? (
                                        <Loader className="animate-spin h-5 w-5 mr-2" />
                                    ) : (
                                        <Save className="h-5 w-5 mr-2" />
                                    )}
                                    {isSaving ? 'Сохранение...' : 'Сохранить'}
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Главный компонент приложения
        const App = () => {
            // === УПРОЩЕННАЯ СИСТЕМА СОХРАНЕНИЯ ПОЗИЦИИ ПРОКРУТКИ ===
            const scrollPosition = useRef(0);

            const saveScrollPosition = () => {
                scrollPosition.current = window.scrollY || document.documentElement.scrollTop;
            };

            const restoreScrollPosition = () => {
                if (scrollPosition.current > 0) {
                    setTimeout(() => {
                        window.scrollTo({
                            top: scrollPosition.current,
                            behavior: 'auto'
                        });
                    }, 10);
                }
            };

            const [authReady, setAuthReady] = useState(false);
            const [userId, setUserId] = useState(null);
            const [albums, setAlbums] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(configError || null);
            const [isAdmin, setIsAdmin] = useState(false);
            const [isLoginModalOpen, setIsLoginModalOpen] = useState(false);
            const [isRenameModalOpen, setIsRenameModalOpen] = useState(false);
            const [albumToRename, setAlbumToRename] = useState(null);
            const [currentView, setCurrentView] = useState('home');
            const [selectedAlbum, setSelectedAlbum] = useState(null);
            const [isDeleteMode, setIsDeleteMode] = useState(false);
            const [isReorderMode, setIsReorderMode] = useState(false);
            const [isAddAlbumModalOpen, setIsAddAlbumModalOpen] = useState(false);
            const [isAddPhotoModalOpen, setIsAddPhotoModalOpen] = useState(false);
            const [isAddDividerModalOpen, setIsAddDividerModalOpen] = useState(false);
            const [enlargedImage, setEnlargedImage] = useState(null);
            const dragItemUniqueId = useRef(null);
            const dragOverItemUniqueId = useRef(null);

            // === НОВЫЕ СОСТОЯНИЯ ДЛЯ ФУНКЦИЙ УПРАВЛЕНИЯ АЛЬБОМАМИ ===
            const [isAlbumReorderMode, setIsAlbumReorderMode] = useState(false);
            const [albumToDelete, setAlbumToDelete] = useState(null);
            const [deleteStep, setDeleteStep] = useState(0);

            // === ИСПРАВЛЕННАЯ ЛОГИКА ОТКРЫТИЯ/ЗАКРЫТИЯ ИЗОБРАЖЕНИЯ ===
            const handleOpenImage = useCallback((image) => {
                saveScrollPosition();
                setEnlargedImage(image);
            }, []);

            const handleCloseImage = useCallback(() => {
                setEnlargedImage(null);
                restoreScrollPosition();
            }, []);

            // === Функции для открытия/закрытия модальных окон с сохранением позиции ===
            const handleOpenAddPhotoModal = useCallback(() => {
                saveScrollPosition();
                setIsAddPhotoModalOpen(true);
            }, []);

            const handleCloseAddPhotoModal = useCallback(() => {
                setIsAddPhotoModalOpen(false);
                restoreScrollPosition();
            }, []);

            const handleOpenAddAlbumModal = useCallback(() => {
                saveScrollPosition();
                setIsAddAlbumModalOpen(true);
            }, []);

            const handleCloseAddAlbumModal = useCallback(() => {
                setIsAddAlbumModalOpen(false);
                restoreScrollPosition();
            }, []);

            const handleOpenAddDividerModal = useCallback(() => {
                saveScrollPosition();
                setIsAddDividerModalOpen(true);
            }, []);

            const handleCloseAddDividerModal = useCallback(() => {
                setIsAddDividerModalOpen(false);
                restoreScrollPosition();
            }, []);

            const handleOpenLoginModal = useCallback(() => {
                saveScrollPosition();
                setIsLoginModalOpen(true);
            }, []);

            const handleCloseLoginModal = useCallback(() => {
                setIsLoginModalOpen(false);
                restoreScrollPosition();
            }, []);

            const handleOpenRenameModal = useCallback((album) => {
                if (!isAdmin) return;
                saveScrollPosition();
                setAlbumToRename(album);
                setIsRenameModalOpen(true);
            }, [isAdmin]);

            const handleCloseRenameModal = useCallback(() => {
                setIsRenameModalOpen(false);
                setAlbumToRename(null);
                restoreScrollPosition();
            }, []);

            // === Функции для управления режимами с сохранением позиции ===
            const toggleDeleteMode = useCallback(() => {
                if (!isAdmin) return;
                saveScrollPosition();
                setIsDeleteMode(prev => !prev);
                if (!isDeleteMode) {
                    setIsReorderMode(false);
                }
                // Восстанавливаем позицию после изменения состояния
                setTimeout(() => {
                    restoreScrollPosition();
                }, 0);
            }, [isDeleteMode, isAdmin]);

            const toggleReorderMode = useCallback(() => {
                if (!isAdmin) return;
                saveScrollPosition();
                setIsReorderMode(prev => !prev);
                if (!isReorderMode) {
                    setIsDeleteMode(false);
                }
                // Восстанавливаем позицию после изменения состояния
                setTimeout(() => {
                    restoreScrollPosition();
                }, 0);
            }, [isReorderMode, isAdmin]);

            // === НОВАЯ ФУНКЦИЯ: Переключение режима сортировки альбомов ===
            const toggleAlbumReorderMode = useCallback(() => {
                if (!isAdmin) return;
                saveScrollPosition();
                setIsAlbumReorderMode(prev => !prev);
                setAlbumToDelete(null);
                setTimeout(() => {
                    restoreScrollPosition();
                }, 0);
            }, [isAdmin]);

            // --- 1. Аутентификация и Настройка ---
            useEffect(() => {
                if (error && error.isCritical) {
                    setAuthReady(true);
                    setLoading(false);
                    return;
                }

                const adminStatus = localStorage.getItem('isAdmin');
                if (adminStatus === 'true') {
                    setIsAdmin(true);
                }

                const setupFirebase = async () => {
                    if (!auth) {
                        setAuthReady(true);
                        return;
                    }
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (e) {
                        console.error("Ошибка аутентификации:", e);
                        setError(prev => ({
                            ...prev,
                            name: "Ошибка аутентификации",
                            message: `Не удалось авторизоваться в Firebase. (Код: ${e.code || 'UNKNOWN'}, Сообщение: ${e.message})`
                        }));
                    }
                };

                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    if (user) {
                        setUserId(user.uid);
                    } else {
                        setUserId(null);
                    }
                    setAuthReady(true);
                });

                setupFirebase();
                return () => unsubscribe();
            }, [error]);

            // Функция для сброса режимов редактирования при смене статуса Admin
            useEffect(() => {
                if (!isAdmin) {
                    setIsDeleteMode(false);
                    setIsReorderMode(false);
                    setIsAlbumReorderMode(false);
                }
            }, [isAdmin]);

            // --- ЛОГИКА АДМИНИСТРАТОРА (Login/Logout) ---
            const handleAdminLogin = async (email, password) => {
                if (!auth) {
                    alertUser('Ошибка', 'Firebase Auth не инициализирован.');
                    return;
                }

                try {
                    const userCredential = await signInWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;

                    if (user.uid === ADMIN_UID) {
                        setIsAdmin(true);
                        setIsLoginModalOpen(false);
                        localStorage.setItem('isAdmin', 'true');
                        alertUser('Успех', 'Вход Администратора выполнен успешно!');
                    } else {
                        await signOut(auth);
                        alertUser('Ошибка доступа', 'Этот аккаунт не имеет прав администратора.');
                    }
                } catch (e) {
                    console.error("Ошибка входа администратора:", e);
                    alertUser('Ошибка входа', `Не удалось войти. Проверьте Email и Пароль. (${e.code})`);
                }
            };

            // Функции навигации в модальном окне
            const handleNavigation = useCallback((direction) => {
                if (!enlargedImage || !selectedAlbum) return;

                const allContent = selectedAlbum.images;
                const images = allContent.filter(item => item.type !== 'divider');

                if (!images || images.length === 0) return;
                
                const currentIndex = images.findIndex(img => img.timestamp === enlargedImage.timestamp);
                if (currentIndex === -1) return;

                let nextIndex;
                if (direction === 'next') {
                    nextIndex = (currentIndex + 1) % images.length;
                } else {
                    nextIndex = (currentIndex - 1 + images.length) % images.length;
                }
                
                const nextImage = images[nextIndex];
                setEnlargedImage(nextImage);
            }, [enlargedImage, selectedAlbum]);

            const handleNextImage = useCallback(() => handleNavigation('next'), [handleNavigation]);
            const handlePrevImage = useCallback(() => handleNavigation('prev'), [handleNavigation]);

            const handleGoHome = useCallback(() => {
                saveScrollPosition();
                setSelectedAlbum(null);
                setCurrentView('home');
                setIsDeleteMode(false);
                setIsReorderMode(false);
                setIsAlbumReorderMode(false);
                restoreScrollPosition();
            }, []);

            const handleOpenAlbum = useCallback((album) => {
                if (isAlbumReorderMode) return;
                saveScrollPosition();
                setSelectedAlbum(album);
                setCurrentView('album');
                setIsDeleteMode(false);
                setIsReorderMode(false);
                setIsAlbumReorderMode(false);
                restoreScrollPosition();
            }, [isAlbumReorderMode]);

            const alertUser = (title, message) => {
                console.warn(`[ВНИМАНИЕ ${title}]: ${message}`);
                if (typeof document !== 'undefined') {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = `
                        <div style="position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border-radius:10px; box-shadow:0 4px 6px rgba(0,0,0,0.2); z-index:1000; max-width: 90vw; text-align: center; border: 2px solid ${title.includes('Ошибка') ? '#ef4444' : '#10b981'}; font-family: sans-serif;">
                            <h4 style="font-weight: bold; color: ${title.includes('Ошибка') ? '#ef4444' : '#10b981'}; margin-bottom: 10px;">${title}</h4>
                            <p>${message}</p>
                            <button onclick="this.parentElement.remove()" style="margin-top: 15px; background: #6366f1; color: white; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer;">OK</button>
                        </div>
                    `;
                    document.body.appendChild(tempDiv.firstChild);
                }
            };

            // --- 2. Получение данных об альбомах (Real-time Listener) ---
            useEffect(() => {
                if (!db || !userId) {
                    if (!userId && authReady) {
                        setLoading(false);
                    }
                    return;
                }

                setLoading(true);

                const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                const q = query(collection(db, collectionPath));

                const unsubscribe = onSnapshot(q,
                    (querySnapshot) => {
                        const fetchedAlbums = [];
                        querySnapshot.forEach((doc) => {
                            const data = doc.data();
                            const images = Array.isArray(data.images) ? data.images : [];
                            fetchedAlbums.push({ id: doc.id, ...data, images });
                        });
                        
                        // НОВАЯ ЛОГИКА СОРТИРОВКИ: сначала по orderIndex, затем по дате
                        fetchedAlbums.sort((a, b) => {
                            const orderA = a.orderIndex !== undefined ? a.orderIndex : Number.MAX_SAFE_INTEGER;
                            const orderB = b.orderIndex !== undefined ? b.orderIndex : Number.MAX_SAFE_INTEGER;
                            
                            if (orderA !== orderB) return orderA - orderB;
                            return (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0);
                        });

                        setAlbums(fetchedAlbums);
                        setLoading(false);
                        
                        setSelectedAlbum(prevSelectedAlbum => {
                            if (prevSelectedAlbum) {
                                const updatedAlbum = fetchedAlbums.find(a => a.id === prevSelectedAlbum.id);
                                if (updatedAlbum) {
                                    return updatedAlbum;
                                }
                                if (currentView === 'album') {
                                    setCurrentView('home');
                                    return null;
                                }
                            }
                            return prevSelectedAlbum;
                        });
                    },
                    (err) => {
                        console.error("Ошибка получения данных Firestore:", err);
                        setError({
                            name: "Ошибка Загрузки Альбомов",
                            message: `Ошибка загрузки альбомов. Проверьте консоль. (${err.message})`
                        });
                        setLoading(false);
                    }
                );

                return () => unsubscribe();
            }, [userId, authReady, currentView]);

            // --- 3. CRUD-функции (Только для Администратора) ---
            
            // === НОВЫЕ ФУНКЦИИ ДЛЯ УПРАВЛЕНИЯ АЛЬБОМАМИ ===
            const initiateDeleteAlbum = (album) => {
                if (!isAdmin) return;
                setAlbumToDelete(album);
                setDeleteStep(1);
            };

            const confirmDeleteAlbum = async () => {
                if (!albumToDelete || !isAdmin) return;

                if (deleteStep === 1) {
                    setDeleteStep(2);
                    return;
                }

                if (deleteStep === 2) {
                    try {
                        const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                        await deleteDoc(doc(db, collectionPath, albumToDelete.id));
                        console.log(`Альбом ${albumToDelete.name} удален.`);
                        setAlbumToDelete(null);
                        setDeleteStep(0);
                    } catch (e) {
                        console.error("Ошибка удаления альбома:", e);
                        alertUser('Ошибка', 'Не удалось удалить альбом.');
                    }
                }
            };

            const cancelDeleteAlbum = () => {
                setAlbumToDelete(null);
                setDeleteStep(0);
            };

            const toggleAlbumVisibility = async (album) => {
                if (!isAdmin) return;
                try {
                    const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                    await updateDoc(doc(db, collectionPath, album.id), {
                        hidden: !album.hidden
                    });
                } catch (e) {
                    console.error("Ошибка обновления видимости:", e);
                    alertUser('Ошибка', 'Не удалось изменить видимость.');
                }
            };

            const renameAlbum = async (albumId, newName) => {
                if (!isAdmin) {
                    alertUser('Ошибка доступа', 'Вы должны быть Администратором для переименования альбомов.');
                    return false;
                }
                if (!albumId || !newName.trim() || !db) {
                    console.error("FIREBASE ERROR: Album ID or DB instance is missing for renameAlbum.");
                    alertUser('Критическая ошибка', 'Не удалось переименовать альбом: не инициализирована база данных.');
                    return false;
                }

                try {
                    const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                    const albumRef = doc(db, collectionPath, albumId);
                    
                    await updateDoc(albumRef, {
                        name: newName.trim(),
                    });

                    console.log(`Альбом ${albumId} переименован в "${newName}"`);
                    handleCloseRenameModal();
                    return true;
                } catch (e) {
                    console.error("Ошибка при переименовании альбома:", e);
                    alertUser('Ошибка', 'Не удалось переименовать альбом.');
                    return false;
                }
            };
            
            const updatePhotoCaption = async (albumId, photoTimestamp, newCaption) => {
                if (!isAdmin) {
                    alertUser('Ошибка доступа', 'Вы должны быть Администратором для редактирования подписей.');
                    return;
                }
                if (!albumId || !db) {
                    console.error("FIREBASE ERROR: Album ID or DB instance is missing for updatePhotoCaption.");
                    alertUser('Критическая ошибка', 'Не удалось сохранить подпись: не инициализирована база данных.');
                    return;
                }

                try {
                    const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                    const albumRef = doc(db, collectionPath, albumId);
                    const currentAlbum = albums.find(a => a.id === albumId);
                    
                    if (currentAlbum) {
                        const updatedImages = currentAlbum.images.map(item => {
                            if (item.timestamp === photoTimestamp && item.type !== 'divider') {
                                return { ...item, caption: newCaption.trim() };
                            }
                            return item;
                        });
                        
                        await updateDoc(albumRef, {
                            images: updatedImages,
                        });

                        setEnlargedImage(prev => {
                            if (prev && prev.timestamp === photoTimestamp) {
                                return { ...prev, caption: newCaption.trim() };
                            }
                            return prev;
                        });
                        
                        console.log(`Подпись для фото ${photoTimestamp} обновлена: "${newCaption}"`);
                    }
                } catch (e) {
                    console.error("Ошибка при обновлении подписи:", e);
                    alertUser('Ошибка', 'Не удалось сохранить подпись.');
                }
            };
            
            const deletePhoto = async (albumId, itemToDelete) => {
                if (!isAdmin) {
                    alertUser('Ошибка доступа', 'Вы должны быть Администратором для удаления элементов.');
                    return;
                }
                if (!albumId || !db) {
                    console.error("FIREBASE ERROR: Album ID or DB instance is missing for deletePhoto.");
                    alertUser('Критическая ошибка', 'Не удалось удалить элемент: не инициализирована база данных.');
                    return;
                }

                try {
                    const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                    const albumRef = doc(db, collectionPath, albumId);
                    const currentAlbum = albums.find(a => a.id === albumId);
                    
                    if (currentAlbum) {
                        const updatedImages = currentAlbum.images.filter(item => item.timestamp !== itemToDelete.timestamp);
                        
                        await updateDoc(albumRef, {
                            images: updatedImages,
                        });
                        
                        console.log(`Элемент (тип: ${itemToDelete.type || 'photo'}) ${itemToDelete.timestamp} удален.`);
                        
                        if (enlargedImage && enlargedImage.timestamp === itemToDelete.timestamp) {
                            handleCloseImage();
                        }
                    }
                } catch (e) {
                    console.error("Ошибка при удалении элемента:", e);
                    alertUser('Ошибка', 'Не удалось удалить элемент.');
                }
            };

            // === НОВЫЕ ФУНКЦИИ ДЛЯ DRAG AND DROP АЛЬБОМОВ ===
            const handleAlbumDragStart = (e, albumId) => {
                if (!isAlbumReorderMode || !isAdmin) return;
                dragItemUniqueId.current = albumId;
                e.dataTransfer.effectAllowed = "move";
            };

            const handleAlbumDragEnter = (e, albumId) => {
                if (!isAlbumReorderMode || !isAdmin) return;
                dragOverItemUniqueId.current = albumId;
            };

            const handleAlbumDrop = async () => {
                if (!isAlbumReorderMode || !isAdmin) return;
                
                const draggedId = dragItemUniqueId.current;
                const targetId = dragOverItemUniqueId.current;
                
                if (!draggedId || !targetId || draggedId === targetId) {
                    dragItemUniqueId.current = null; dragOverItemUniqueId.current = null;
                    return;
                }

                const newAlbums = [...albums];
                const draggedIndex = newAlbums.findIndex(a => a.id === draggedId);
                const targetIndex = newAlbums.findIndex(a => a.id === targetId);

                if (draggedIndex === -1 || targetIndex === -1) return;

                const [movedAlbum] = newAlbums.splice(draggedIndex, 1);
                newAlbums.splice(targetIndex, 0, movedAlbum);

                setAlbums(newAlbums);

                try {
                    const batch = writeBatch(db);
                    const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                    
                    newAlbums.forEach((album, index) => {
                        const ref = doc(db, collectionPath, album.id);
                        batch.update(ref, { orderIndex: index });
                    });
                    
                    await batch.commit();
                    console.log("Порядок альбомов обновлен");
                } catch (e) {
                    console.error("Ошибка сохранения порядка альбомов:", e);
                    alertUser('Ошибка', 'Не удалось сохранить порядок.');
                }

                dragItemUniqueId.current = null;
                dragOverItemUniqueId.current = null;
            };

            const handleDragStart = useCallback((e, uniqueId) => {
                if (!isReorderMode || !isAdmin) return;
                saveScrollPosition();
                dragItemUniqueId.current = uniqueId;
                e.dataTransfer.effectAllowed = "move";
                if (e.dataTransfer.setDragImage) {
                     const dragElement = e.target.closest('div').querySelector('img') || e.target.closest('div').querySelector('h2');
                     if(dragElement) e.dataTransfer.setDragImage(dragElement, 10, 10);
                }
            }, [isReorderMode, isAdmin]);

            const handleDragEnter = useCallback((e, uniqueId) => {
                if (!isReorderMode || !isAdmin) return;
                dragOverItemUniqueId.current = uniqueId;
            }, [isReorderMode, isAdmin]);

            const handleDragOver = useCallback((e) => {
                if (!isReorderMode || !isAdmin) return;
                e.preventDefault();
            }, [isReorderMode, isAdmin]);

            const handleDrop = useCallback(async (e) => {
                if (!isAdmin) {
                    alertUser('Ошибка доступа', 'Вы должны быть Администратором для изменения порядка.');
                    dragItemUniqueId.current = null;
                    dragOverItemUniqueId.current = null;
                    return;
                }
                if (!isReorderMode) {
                    return;
                }
                if (!selectedAlbum || !db) {
                    console.error("FIREBASE ERROR: Album or DB instance is missing for handleDrop.");
                    alertUser('Критическая ошибка', 'Не удалось изменить порядок: не инициализирован альбом или база данных.');
                    dragItemUniqueId.current = null;
                    dragOverItemUniqueId.current = null;
                    return;
                }

                const draggedId = dragItemUniqueId.current;
                const targetId = dragOverItemUniqueId.current;

                if (draggedId === null || targetId === null || draggedId === targetId) {
                    dragItemUniqueId.current = null;
                    dragOverItemUniqueId.current = null;
                    return;
                }

                const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                const albumRef = doc(db, collectionPath, selectedAlbum.id);
                const list = [...selectedAlbum.images];

                const draggedIndex = list.findIndex(item => item.timestamp === draggedId);
                const targetIndex = list.findIndex(item => item.timestamp === targetId);

                if (draggedIndex === -1 || targetIndex === -1) {
                    console.error("Не удалось найти элемент по ID при перетаскивании.");
                    dragItemUniqueId.current = null;
                    dragOverItemUniqueId.current = null;
                    return;
                }

                const itemToMove = list[draggedIndex];
                list.splice(draggedIndex, 1);
                list.splice(targetIndex, 0, itemToMove);

                try {
                    await updateDoc(albumRef, {
                        images: list
                    });
                    console.log("Порядок элементов галереи обновлен в Firestore.");
                } catch (error) {
                    console.error("Ошибка обновления порядка:", error);
                    alertUser('Ошибка', 'Не удалось сохранить новый порядок элементов.');
                }
                
                dragItemUniqueId.current = null;
                dragOverItemUniqueId.current = null;
                // Восстанавливаем позицию после перетаскивания
                setTimeout(() => {
                    restoreScrollPosition();
                }, 0);
            }, [isReorderMode, isAdmin, selectedAlbum, db]);

            const addDivider = async (albumId, text) => {
                if (!isAdmin) {
                    alertUser('Ошибка доступа', 'Вы должны быть Администратором для добавления разделителей.');
                    return;
                }
                if (!albumId || !text.trim() || !db) {
                    alertUser('Критическая ошибка', 'Не удалось добавить разделитель: не инициализирована база данных.');
                    return;
                }

                try {
                    const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                    const albumRef = doc(db, collectionPath, albumId);
                    
                    const newDividerEntry = {
                        type: 'divider',
                        timestamp: Date.now(),
                        text: text.trim(),
                    };
                    
                    await updateDoc(albumRef, {
                        images: arrayUnion(newDividerEntry)
                    });

                    setIsAddDividerModalOpen(false);
                    console.log(`Разделитель "${text}" добавлен в альбом ${albumId}.`);
                } catch (e) {
                    console.error("Ошибка при добавлении разделителя:", e);
                    alertUser('Ошибка', 'Не удалось добавить текстовый разделитель.');
                }
            };

            const createNewAlbum = async (name) => {
                if (!isAdmin) {
                    alertUser('Ошибка доступа', 'Вы должны быть Администратором для создания альбомов.');
                    return;
                }
                if (!name.trim() || !db) {
                    alertUser('Критическая ошибка', 'Не удалось создать альбом: не инициализирована база данных.');
                    return;
                }

                try {
                    const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                    // Добавляем orderIndex в конец списка
                    const maxOrderIndex = albums.length > 0 ? Math.max(...albums.map(a => a.orderIndex || 0)) : 0;
                    
                    await addDoc(collection(db, collectionPath), {
                        name: name.trim(),
                        createdAt: serverTimestamp(),
                        images: [], 
                        hidden: false,
                        orderIndex: maxOrderIndex + 1
                    });
                    setIsAddAlbumModalOpen(false);
                    console.log(`Альбом "${name}" создан.`);
                } catch (e) {
                    console.error("Ошибка при создании альбома:", e);
                    alertUser('Ошибка', 'Не удалось создать альбом.');
                }
            };

            const addPhotoLink = async (albumId, url, aspectRatio = 1.0) => {
                if (!isAdmin) {
                    alertUser('Ошибка доступа', 'Вы должны быть Администратором для добавления фото.');
                    return;
                }
                if (!albumId || !url.trim() || !db) {
                    alertUser('Критическая ошибка', 'Не удалось добавить фото: не инициализирована база данных.');
                    return;
                }

                try {
                    const collectionPath = `artifacts/${appId}/public/data/${PUBLIC_COLLECTION_NAME}`;
                    const albumRef = doc(db, collectionPath, albumId);
                    
                    const newImageEntry = {
                        url: url.trim(),
                        type: 'photo',
                        timestamp: Date.now(),
                        aspectRatio: parseFloat(aspectRatio) > 0 ? parseFloat(aspectRatio) : 1.0,
                        caption: ''
                    };
                    
                    await updateDoc(albumRef, {
                        images: arrayUnion(newImageEntry)
                    });

                    setIsAddPhotoModalOpen(false);
                    console.log(`Ссылка добавлена в альбом ${albumId}.`);
                } catch (e) {
                    console.error("Ошибка при добавлении ссылки:", e);
                    alertUser('Ошибка', 'Не удалось добавить ссылку на фото. Убедитесь, что ссылка корректна.');
                }
            };

            // --- Вспомогательные компоненты ---
            const AlbumCard = ({ album }) => {
                const firstPhoto = album.images.find(item => item.type !== 'divider' && item.url);
                const previewUrl = firstPhoto ? firstPhoto.url : null;
                const imageCount = album.images.filter(item => item.type !== 'divider').length;
                
                const opacityClass = album.hidden ? 'opacity-60 grayscale' : 'opacity-100';
                const hiddenBadge = album.hidden ? (
                    <div className="absolute top-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs flex items-center">
                        <EyeOff size={12} className="mr-1"/> Скрыт
                    </div>
                ) : null;

                const isDragging = isAlbumReorderMode && dragItemUniqueId.current === album.id;
                const isDragOver = isAlbumReorderMode && dragOverItemUniqueId.current === album.id;

                return (
                    <div 
                        className={`
                            relative group transition-all duration-200
                            ${isAlbumReorderMode ? 'cursor-move' : ''}
                            ${isDragging ? 'opacity-20 scale-95' : ''}
                            ${isDragOver ? 'transform scale-105' : ''}
                        `}
                        draggable={isAlbumReorderMode && isAdmin}
                        onDragStart={(e) => handleAlbumDragStart(e, album.id)}
                        onDragEnter={(e) => handleAlbumDragEnter(e, album.id)}
                        onDragOver={(e) => e.preventDefault()}
                        onDrop={handleAlbumDrop}
                    >
                        <div 
                            onClick={() => handleOpenAlbum(album)}
                            className={`bg-white rounded-xl shadow-lg hover:shadow-xl transition-shadow cursor-pointer overflow-hidden ${opacityClass} ${isDragOver ? 'ring-2 ring-indigo-500' : ''}`}
                        >
                            <div className="w-full bg-gray-200 flex items-center justify-center relative">
                                {previewUrl ? (
                                    <img 
                                        src={previewUrl} 
                                        alt={`Превью ${album.name}`} 
                                        className="w-full h-full object-cover"
                                        onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/600x400/CCCCCC/333333?text=Ошибка+загрузки"; }}
                                    />
                                ) : (
                                    <ImageIcon className="w-1/3 h-1/3 text-gray-500" />
                                )}
                                {hiddenBadge}
                            </div>
                            <div className="p-4">
                                <h3 className="font-semibold text-lg text-gray-800 truncate" title={album.name}>{album.name}</h3>
                                <p className="text-sm text-gray-500 mt-1">{imageCount} {imageCount === 1 ? 'фото' : (imageCount > 1 && imageCount < 5 ? 'фото' : 'фотографий')}</p>
                            </div>
                        </div>
                        
                        {/* КНОПКИ УПРАВЛЕНИЯ АЛЬБОМОМ (Только Админ) */}
                        {isAdmin && !isAlbumReorderMode && (
                            <div className="absolute top-2 right-2 flex flex-col space-y-2 opacity-0 group-hover:opacity-100 transition-opacity z-10">
                                {/* Редактировать имя */}
                                <button
                                    onClick={(e) => { e.stopPropagation(); handleOpenRenameModal(album); }}
                                    className="p-1.5 bg-white rounded-full shadow-md text-gray-700 hover:text-indigo-600 hover:bg-gray-50"
                                    title="Переименовать"
                                >
                                    <Edit size={16} />
                                </button>
                                
                                {/* Скрыть/Показать */}
                                <button
                                    onClick={(e) => { e.stopPropagation(); toggleAlbumVisibility(album); }}
                                    className={`p-1.5 bg-white rounded-full shadow-md hover:bg-gray-50 ${album.hidden ? 'text-indigo-600' : 'text-gray-500'}`}
                                    title={album.hidden ? "Сделать публичным" : "Скрыть альбом"}
                                >
                                    {album.hidden ? <Eye size={16} /> : <EyeOff size={16} />}
                                </button>

                                {/* Удалить */}
                                <button
                                    onClick={(e) => { e.stopPropagation(); initiateDeleteAlbum(album); }}
                                    className="p-1.5 bg-white rounded-full shadow-md text-red-500 hover:text-red-700 hover:bg-red-50"
                                    title="Удалить альбом"
                                >
                                    <Trash2 size={16} />
                                </button>
                            </div>
                        )}
                    </div>
                );
            };

            const LoadingSpinner = () => (
                <div className="flex justify-center items-center h-full min-h-[300px]">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
                    <p className="ml-4 text-gray-600">Загрузка данных...</p>
                </div>
            );
            
            const CalculationSpinner = () => (
                <div className="flex justify-center items-center h-full min-h-[100px] my-8">
                     <Loader className="animate-spin text-indigo-500 mr-3" size={24} />
                    <p className="text-gray-600">Расчет макета галереи...</p>
                </div>
            );

            const Modal = ({ isOpen, onClose, title, children }) => {
                if (!isOpen) return null;
                
                return (
                    <div className="fixed inset-0 z-50 bg-black bg-opacity-50 flex justify-center items-center p-4" onClick={onClose}>
                        <div 
                            className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 animate-fade-in-up"
                            onClick={(e) => e.stopPropagation()}
                        >
                            <div className="flex justify-between items-center border-b pb-3 mb-4">
                                <h2 className="text-xl font-bold text-gray-800">{title}</h2>
                                <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                                    <X size={24} />
                                </button>
                            </div>
                            {children}
                        </div>
                    </div>
                );
            };

            // === НОВЫЙ КОМПОНЕНТ: Модальное окно подтверждения удаления альбома ===
            const DeleteAlbumConfirmModal = () => {
                if (!albumToDelete) return null;

                return (
                    <div className="fixed inset-0 z-[100] bg-black bg-opacity-60 flex justify-center items-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm p-6 text-center animate-fade-in-up">
                            <div className="mb-4 flex justify-center text-red-500">
                                <AlertTriangle size={48} />
                            </div>
                            
                            {deleteStep === 1 && (
                                <>
                                    <h3 className="text-xl font-bold text-gray-800 mb-2">Удалить альбом?</h3>
                                    <p className="text-gray-600 mb-6">Вы хотите удалить альбом <b>"{albumToDelete.name}"</b>?</p>
                                    <div className="flex justify-center space-x-3">
                                        <button onClick={cancelDeleteAlbum} className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200">Отмена</button>
                                        <button onClick={confirmDeleteAlbum} className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Да, удалить</button>
                                    </div>
                                </>
                            )}

                            {deleteStep === 2 && (
                                <>
                                    <h3 className="text-xl font-bold text-red-600 mb-2">Вы абсолютно уверены?</h3>
                                    <p className="text-gray-600 mb-6">Это действие <b>нельзя отменить</b>. Все фотографии в этом альбоме будут потеряны.</p>
                                    <div className="flex justify-center space-x-3">
                                        <button onClick={cancelDeleteAlbum} className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200">Нет, оставить</button>
                                        <button onClick={confirmDeleteAlbum} className="px-4 py-2 bg-red-700 text-white rounded-lg hover:bg-red-800 shadow-lg font-bold">ДА, УДАЛИТЬ НАВСЕГДА</button>
                                    </div>
                                </>
                            )}
                        </div>
                    </div>
                );
            };
            
            const RenameAlbumModal = () => {
                const [newName, setNewName] = useState(albumToRename?.name || '');
                const [isSaving, setIsSaving] = useState(false);

                useEffect(() => {
                    setNewName(albumToRename?.name || '');
                }, [albumToRename]);
                
                const handleSubmit = async (e) => {
                    e.preventDefault();
                    if (newName.trim() && albumToRename) {
                        setIsSaving(true);
                        await renameAlbum(albumToRename.id, newName);
                        setIsSaving(false);
                    }
                };

                return (
                    <Modal isOpen={isRenameModalOpen} onClose={handleCloseRenameModal} title={`Переименовать альбом "${albumToRename?.name || ''}"`}>
                        <form onSubmit={handleSubmit}>
                            <input
                                type="text"
                                value={newName}
                                onChange={(e) => setNewName(e.target.value)}
                                placeholder="Введите новое название альбома"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
                                required
                            />
                            <div className="flex justify-end mt-4 space-x-3">
                                <button type="button" onClick={handleCloseRenameModal} className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition">
                                    Отмена
                                </button>
                                <button 
                                    type="submit" 
                                    disabled={isSaving || !newName.trim() || newName.trim() === albumToRename?.name}
                                    className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition shadow-md disabled:bg-indigo-400"
                                >
                                    {isSaving ? 'Сохранение...' : 'Сохранить'}
                                </button>
                            </div>
                        </form>
                    </Modal>
                );
            };
            
            const AdminLoginModal = () => {
                const [email, setEmail] = useState('');
                const [password, setPassword] = useState('');

                const handleSubmit = (e) => {
                    e.preventDefault();
                    handleAdminLogin(email, password);
                    setPassword('');
                };

                return (
                    <Modal
                        isOpen={isLoginModalOpen}
                        onClose={handleCloseLoginModal}
                        title="Вход Администратора"
                    >
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <input
                                type="email"
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                placeholder="Введите email администратора"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
                                required
                            />
                            <input
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                placeholder="Введите пароль администратора"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
                                required
                            />
                            <div className="flex justify-end mt-4 space-x-3">
                                <button
                                    type="button"
                                    onClick={handleCloseLoginModal}
                                    className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition"
                                >
                                    Отмена
                                </button>
                                <button
                                    type="submit"
                                    className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition shadow-md"
                                >
                                    Войти
                                </button>
                            </div>
                        </form>
                    </Modal>
                );
            };

            const AddAlbumModal = () => {
                const [albumName, setAlbumName] = useState('');
                
                const handleSubmit = (e) => {
                    e.preventDefault();
                    if (albumName.trim()) {
                        createNewAlbum(albumName);
                    }
                };

                return (
                    <Modal isOpen={isAddAlbumModalOpen} onClose={handleCloseAddAlbumModal} title="Создать новый альбом">
                        <form onSubmit={handleSubmit}>
                            <input
                                type="text"
                                value={albumName}
                                onChange={(e) => setAlbumName(e.target.value)}
                                placeholder="Введите название альбома"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
                                required
                            />
                            <div className="flex justify-end mt-4 space-x-3">
                                <button type="button" onClick={handleCloseAddAlbumModal} className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition">
                                    Отмена
                                </button>
                                <button type="submit" className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition shadow-md">
                                    Создать
                                </button>
                            </div>
                        </form>
                    </Modal>
                );
            };

            const AddDividerModal = () => {
                const [dividerText, setDividerText] = useState('');
                
                const handleSubmit = (e) => {
                    e.preventDefault();
                    if (dividerText.trim() && selectedAlbum) {
                        addDivider(selectedAlbum.id, dividerText);
                        setDividerText('');
                    }
                };

                return (
                    <Modal isOpen={isAddDividerModalOpen} onClose={handleCloseAddDividerModal} title="Добавить текстовый разделитель">
                        <form onSubmit={handleSubmit}>
                            <label className="block text-sm font-medium text-gray-700 mb-1">Текст главы/раздела</label>
                            <input
                                type="text"
                                value={dividerText}
                                onChange={(e) => setDividerText(e.target.value)}
                                placeholder="Глава ..."
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
                                required
                            />
                            <div className="flex justify-end mt-4 space-x-3">
                                <button type="button" onClick={handleCloseAddDividerModal} className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition">
                                    Отмена
                                </button>
                                <button type="submit" className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition shadow-md">
                                    Добавить разделитель
                                </button>
                            </div>
                        </form>
                    </Modal>
                );
            };

            const AddPhotoModal = () => {
                const [photoUrl, setPhotoUrl] = useState('');
                const [aspectRatio, setAspectRatio] = useState('1.0');
                const [selectedAlbumId, setSelectedAlbumId] = useState('');
                const [previewImage, setPreviewImage] = useState(null);

                useEffect(() => {
                    if (albums.length > 0 && !selectedAlbumId) {
                        if (currentView === 'album' && selectedAlbum) {
                            setSelectedAlbumId(selectedAlbum.id);
                        } else {
                            setSelectedAlbumId(albums[0].id);
                        }
                    }
                }, [albums, selectedAlbumId, currentView, selectedAlbum]);

                const handleSubmit = (e) => {
                    e.preventDefault();
                    if (selectedAlbumId && photoUrl.trim()) {
                        const ratio = parseFloat(aspectRatio.replace(',', '.'));
                        if (isNaN(ratio) || ratio <= 0) {
                             alertUser('Ошибка', 'Некорректное соотношение сторон. Введите число > 0.');
                             return;
                        }
                        addPhotoLink(selectedAlbumId, photoUrl, ratio);
                        setPhotoUrl('');
                        setAspectRatio('1.0');
                        setPreviewImage(null);
                    }
                };

                const handleUrlChange = (e) => {
                    const url = e.target.value;
                    setPhotoUrl(url);
                    setPreviewImage(null);
                    if (url.startsWith('http')) {
                        setPreviewImage(url);
                    }
                };

                useEffect(() => {
                    if (!previewImage) return;
                    const img = new Image();
                    img.onload = () => {
                        if (img.naturalWidth && img.naturalHeight) {
                            const ratio = (img.naturalWidth / img.naturalHeight).toFixed(3);
                            setAspectRatio(ratio);
                            console.log(`Авто-пропорции определены: ${ratio}`);
                        }
                    };
                    img.onerror = () => {
                        console.warn("Не удалось определить пропорции изображения.");
                    };
                    img.src = previewImage;
                }, [previewImage]);

                return (
                    <Modal isOpen={isAddPhotoModalOpen} onClose={handleCloseAddPhotoModal} title="Добавить фото по ссылке">
                        <form onSubmit={handleSubmit}>
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">URL изображения (Imgur, GitHub и т.д.)</label>
                                    <input
                                        type="url"
                                        value={photoUrl}
                                        onChange={handleUrlChange}
                                        placeholder="https://i.imgur.com/your-image.jpg"
                                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
                                        required
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Соотношение сторон (Ширина/Высота)</label>
                                    <input
                                        type="text"
                                        value={aspectRatio}
                                        onChange={(e) => setAspectRatio(e.target.value)}
                                        placeholder="1.0 (для квадрата) или 1.5 (для 3:2)"
                                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
                                        required
                                    />
                                    <p className="text-xs text-gray-500 mt-1">
                                        Обязательно укажите число: 1.0 (квадрат), 1.77 (16:9), 0.56 (9:16). 
                                    </p>
                                </div>
                                {previewImage && (
                                    <div className="p-3 bg-gray-50 rounded-lg border border-gray-200">
                                        <p className="text-xs text-gray-600 mb-2">Предпросмотр:</p>
                                        <img 
                                            src={previewImage} 
                                            alt="Превью" 
                                            className="w-full max-h-32 object-contain rounded"
                                            onError={(e) => { e.target.onerror = null; setPreviewImage(null); console.log("Не удалось загрузить превью. Проверьте ссылку."); }}
                                        />
                                    </div>
                                )}
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Выбрать альбом</label>
                                    <select
                                        value={selectedAlbumId}
                                        onChange={(e) => setSelectedAlbumId(e.target.value)}
                                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 bg-white"
                                        required
                                    >
                                        {albums.map(album => (
                                            <option key={album.id} value={album.id}>{album.name}</option>
                                        ))}
                                    </select>
                                    {albums.length === 0 && <p className="text-red-500 text-xs mt-1">Создайте альбом, чтобы добавить фото.</p>}
                                </div>
                            </div>
                            <div className="flex justify-end mt-6 space-x-3">
                                <button type="button" onClick={handleCloseAddPhotoModal} className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition">
                                    Отмена
                                </button>
                                <button 
                                    type="submit" 
                                    disabled={albums.length === 0 || !aspectRatio || isNaN(parseFloat(aspectRatio.replace(',', '.'))) || parseFloat(aspectRatio.replace(',', '.')) <= 0} 
                                    className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition shadow-md disabled:bg-indigo-400"
                                >
                                    Добавить фото
                                </button>
                            </div>
                        </form>
                    </Modal>
                );
            };
            
            const AlbumPhotoView = ({ onOpenImage }) => {
                if (!selectedAlbum) return <HomeView />;

                const albumRef = useRef(null);
                const [containerWidth, setContainerWidth] = useState(0);

                const updateWidth = useCallback(() => {
                    if (albumRef.current) {
                        setContainerWidth(albumRef.current.clientWidth);
                    }
                }, []);

                useEffect(() => {
                    updateWidth();
                    const resizeObserver = new ResizeObserver(updateWidth);
                    if (albumRef.current) {
                        resizeObserver.observe(albumRef.current);
                    }
                    return () => {
                        resizeObserver.disconnect();
                    };
                }, [updateWidth]);

                const allContent = selectedAlbum.images;

                const justifiedRows = useMemo(() => {
                    if (containerWidth <= 0) return [];
                    
                    const rows = [];
                    
                    const calculateGapWidth = (count) => (count - 1) * GALLERY_GAP_PX;

                    // УЛУЧШЕННАЯ функция для оптимального распределения фото
                    const distributePhotosOptimally = (photos, targetHeight, containerWidth) => {
                        if (photos.length === 0) return [];
                        
                        const rows = [];
                        
                        // Основной алгоритм распределения
                        let startIndex = 0;
                        
                        while (startIndex < photos.length) {
                            let bestRow = [photos[startIndex]];
                            let bestCost = calculateRowCost(bestRow, targetHeight, containerWidth);
                            
                            // Пробуем добавлять фото в ряд
                            for (let endIndex = startIndex + 1; endIndex <= Math.min(startIndex + 10, photos.length); endIndex++) {
                                const candidateRow = photos.slice(startIndex, endIndex + 1);
                                const candidateCost = calculateRowCost(candidateRow, targetHeight, containerWidth);
                                
                                if (candidateCost < bestCost) {
                                    bestRow = candidateRow;
                                    bestCost = candidateCost;
                                } else {
                                    break;
                                }
                            }
                            
                            // Рассчитываем финальную высоту для выбранного ряда
                            const totalAspect = bestRow.reduce((sum, img) => sum + img.aspectRatio, 0);
                            const gapWidth = calculateGapWidth(bestRow.length);
                            const finalHeight = Math.min(
                                (containerWidth - gapWidth) / totalAspect,
                                TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER
                            );
                            
                            const minAllowedHeight = startIndex + bestRow.length >= photos.length ? 
                                TARGET_ROW_HEIGHT * 0.5 : 
                                TARGET_ROW_HEIGHT * 0.7;
                            
                            const clampedHeight = Math.max(finalHeight, minAllowedHeight);
                            
                            rows.push({
                                photos: bestRow,
                                height: clampedHeight
                            });
                            
                            startIndex += bestRow.length;
                        }
                        
                        // === УЛУЧШЕННАЯ ПОСТ-ОБРАБОТКА: Оптимизация последних рядов ===
                        if (rows.length >= 2) {
                            const lastRow = rows[rows.length - 1];
                            const secondLastRow = rows[rows.length - 2];
                            
                            // Рассчитываем ширину последнего ряда
                            const lastRowTotalWidth = lastRow.photos.reduce((sum, img) => sum + img.aspectRatio * lastRow.height, 0) + 
                                                    calculateGapWidth(lastRow.photos.length);
                            
                            const lastRowFillRatio = lastRowTotalWidth / containerWidth;
                            
                            // СЛУЧАЙ 1: Если в последнем ряду 2 или меньше фото - ВСЕГДА объединяем с предпоследним
                            if (lastRow.photos.length < 3) {
                                const mergedPhotos = [...secondLastRow.photos, ...lastRow.photos];
                                const totalAspect = mergedPhotos.reduce((sum, img) => sum + img.aspectRatio, 0);
                                const gapWidth = calculateGapWidth(mergedPhotos.length);
                                
                                // Пересчитываем высоту объединенного ряда
                                const newHeight = Math.min(
                                    (containerWidth - gapWidth) / totalAspect,
                                    TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER
                                );
                                
                                // Проверяем, что новая высота не слишком маленькая
                                if (newHeight >= TARGET_ROW_HEIGHT * 0.4) {
                                    rows[rows.length - 2] = {
                                        photos: mergedPhotos,
                                        height: newHeight
                                    };
                                    rows.pop();
                                }
                            }
                            // СЛУЧАЙ 2: Если в последнем ряду 3 фото и они заполняют меньше 95% ширины
                            else if (lastRow.photos.length === 3 && lastRowFillRatio < 0.95) {
                                // АГРЕССИВНО: Пробуем переместить от 1 до 3 фото из предпоследнего ряда
                                let bestMoveCount = 0;
                                let bestNewFillRatio = lastRowFillRatio;
                                let bestNewSecondLastHeight = secondLastRow.height;
                                let bestNewLastHeight = lastRow.height;
                                
                                for (let moveCount = 1; moveCount <= Math.min(3, secondLastRow.photos.length - 1); moveCount++) {
                                    const newSecondLastPhotos = secondLastRow.photos.slice(0, -moveCount);
                                    const newLastPhotos = [...secondLastRow.photos.slice(-moveCount), ...lastRow.photos];
                                    
                                    // Пересчитываем высоты
                                    const newSecondLastAspect = newSecondLastPhotos.reduce((sum, img) => sum + img.aspectRatio, 0);
                                    const newLastAspect = newLastPhotos.reduce((sum, img) => sum + img.aspectRatio, 0);
                                    
                                    const newSecondLastGap = calculateGapWidth(newSecondLastPhotos.length);
                                    const newLastGap = calculateGapWidth(newLastPhotos.length);
                                    
                                    const newSecondLastHeight = Math.min(
                                        (containerWidth - newSecondLastGap) / newSecondLastAspect,
                                        TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER
                                    );
                                    
                                    const newLastHeight = Math.min(
                                        (containerWidth - newLastGap) / newLastAspect,
                                        TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER
                                    );
                                    
                                    // Проверяем минимальные высоты
                                    if (newSecondLastHeight >= TARGET_ROW_HEIGHT * 0.45 && newLastHeight >= TARGET_ROW_HEIGHT * 0.45) {
                                        // Рассчитываем новое заполнение последнего ряда
                                        const newLastRowWidth = newLastPhotos.reduce((sum, img) => sum + img.aspectRatio * newLastHeight, 0) + 
                                                              calculateGapWidth(newLastPhotos.length);
                                        const newLastRowFillRatio = newLastRowWidth / containerWidth;
                                        
                                        // Выбираем вариант с лучшим заполнением
                                        if (newLastRowFillRatio > bestNewFillRatio) {
                                            bestMoveCount = moveCount;
                                            bestNewFillRatio = newLastRowFillRatio;
                                            bestNewSecondLastHeight = newSecondLastHeight;
                                            bestNewLastHeight = newLastHeight;
                                        }
                                    }
                                }
                                
                                // Если нашли хорошее перераспределение, применяем его
                                if (bestMoveCount > 0 && bestNewFillRatio > lastRowFillRatio + 0.1) {
                                    const newSecondLastPhotos = secondLastRow.photos.slice(0, -bestMoveCount);
                                    const newLastPhotos = [...secondLastRow.photos.slice(-bestMoveCount), ...lastRow.photos];
                                    
                                    rows[rows.length - 2] = {
                                        photos: newSecondLastPhotos,
                                        height: bestNewSecondLastHeight
                                    };
                                    rows[rows.length - 1] = {
                                        photos: newLastPhotos,
                                        height: bestNewLastHeight
                                    };
                                }
                            }
                            // СЛУЧАЙ 3: Если в последнем ряду больше 3 фото, но все равно мало заполнен (менее 85%)
                            else if (lastRow.photos.length > 3 && lastRowFillRatio < 0.85 && secondLastRow.photos.length >= 4) {
                                // АГРЕССИВНО: Пробуем переместить 1-2 фото из предпоследнего ряда
                                for (let moveCount = 1; moveCount <= 2; moveCount++) {
                                    if (secondLastRow.photos.length - moveCount < 2) break;
                                    
                                    const newSecondLastPhotos = secondLastRow.photos.slice(0, -moveCount);
                                    const newLastPhotos = [...secondLastRow.photos.slice(-moveCount), ...lastRow.photos];
                                    
                                    const newSecondLastAspect = newSecondLastPhotos.reduce((sum, img) => sum + img.aspectRatio, 0);
                                    const newLastAspect = newLastPhotos.reduce((sum, img) => sum + img.aspectRatio, 0);
                                    
                                    const newSecondLastGap = calculateGapWidth(newSecondLastPhotos.length);
                                    const newLastGap = calculateGapWidth(newLastPhotos.length);
                                    
                                    const newSecondLastHeight = Math.min(
                                        (containerWidth - newSecondLastGap) / newSecondLastAspect,
                                        TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER
                                    );
                                    
                                    const newLastHeight = Math.min(
                                        (containerWidth - newLastGap) / newLastAspect,
                                        TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER
                                    );
                                    
                                    // Проверяем, что улучшилось заполнение
                                    const newLastRowWidth = newLastPhotos.reduce((sum, img) => sum + img.aspectRatio * newLastHeight, 0) + 
                                                          calculateGapWidth(newLastPhotos.length);
                                    const newLastRowFillRatio = newLastRowWidth / containerWidth;
                                    
                                    if (newLastRowFillRatio > lastRowFillRatio + 0.15 && 
                                        newSecondLastHeight >= TARGET_ROW_HEIGHT * 0.4 && 
                                        newLastHeight >= TARGET_ROW_HEIGHT * 0.4) {
                                        
                                        rows[rows.length - 2] = {
                                            photos: newSecondLastPhotos,
                                            height: newSecondLastHeight
                                        };
                                        rows[rows.length - 1] = {
                                            photos: newLastPhotos,
                                            height: newLastHeight
                                        };
                                        break;
                                    }
                                }
                            }
                            // СЛУЧАЙ 4: АГРЕССИВНОЕ ВЫРАВНИВАНИЕ - для случаев, когда в предпоследнем ряду много фото (8+), а в последнем мало (3-4)
                            else if (secondLastRow.photos.length >= 8 && lastRow.photos.length <= 4 && lastRowFillRatio < 0.9) {
                                // Рассчитываем, сколько фото нужно переместить для оптимального заполнения
                                const targetLastRowCount = Math.min(6, Math.max(4, Math.floor(secondLastRow.photos.length * 0.4)));
                                const photosToMove = targetLastRowCount - lastRow.photos.length;
                                
                                if (photosToMove > 0 && secondLastRow.photos.length - photosToMove >= 4) {
                                    const newSecondLastPhotos = secondLastRow.photos.slice(0, -photosToMove);
                                    const newLastPhotos = [...secondLastRow.photos.slice(-photosToMove), ...lastRow.photos];
                                    
                                    const newSecondLastAspect = newSecondLastPhotos.reduce((sum, img) => sum + img.aspectRatio, 0);
                                    const newLastAspect = newLastPhotos.reduce((sum, img) => sum + img.aspectRatio, 0);
                                    
                                    const newSecondLastGap = calculateGapWidth(newSecondLastPhotos.length);
                                    const newLastGap = calculateGapWidth(newLastPhotos.length);
                                    
                                    const newSecondLastHeight = Math.min(
                                        (containerWidth - newSecondLastGap) / newSecondLastAspect,
                                        TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER
                                    );
                                    
                                    const newLastHeight = Math.min(
                                        (containerWidth - newLastGap) / newLastAspect,
                                        TARGET_ROW_HEIGHT * MAX_ROW_HEIGHT_MULTIPLIER
                                    );
                                    
                                    // Проверяем, что высоты в допустимых пределах
                                    if (newSecondLastHeight >= TARGET_ROW_HEIGHT * 0.4 && newLastHeight >= TARGET_ROW_HEIGHT * 0.4) {
                                        rows[rows.length - 2] = {
                                            photos: newSecondLastPhotos,
                                            height: newSecondLastHeight
                                        };
                                        rows[rows.length - 1] = {
                                            photos: newLastPhotos,
                                            height: newLastHeight
                                        };
                                    }
                                }
                            }
                        }

                        // === АГРЕССИВНОЕ ВЫРАВНИВАНИЕ: Увеличиваем все ряды до полного заполнения ===
                        for (let i = 0; i < rows.length; i++) {
                            const row = rows[i];
                            const totalAspect = row.photos.reduce((sum, img) => sum + img.aspectRatio, 0);
                            const gapWidth = calculateGapWidth(row.photos.length);
                            const currentWidth = totalAspect * row.height + gapWidth;
                            const fillRatio = currentWidth / containerWidth;

                            // Если ряд заполнен более чем на 85% но менее 100%, увеличиваем его до 100%
                            if (fillRatio >= 0.85 && fillRatio < 1.0) {
                                const desiredHeight = (containerWidth - gapWidth) / totalAspect;
                                // Ограничиваем максимальной высотой
                                const maxAllowedHeight = TARGET_ROW_HEIGHT * (MAX_ROW_HEIGHT_MULTIPLIER + 0.3);
                                
                                const newHeight = Math.min(desiredHeight, maxAllowedHeight);
                                
                                // Если новая высота не меньше текущей (увеличиваем) и при этом не превышает максимальную, то применяем
                                if (newHeight >= row.height && newHeight <= maxAllowedHeight) {
                                    row.height = newHeight;
                                }
                            }
                        }
                        
                        return rows;
                    };

                    // Функция для расчета "стоимости" ряда
                    const calculateRowCost = (rowPhotos, targetHeight, containerWidth) => {
                        if (rowPhotos.length === 0) return Infinity;
                        
                        const totalAspect = rowPhotos.reduce((sum, img) => sum + img.aspectRatio, 0);
                        const gapWidth = (rowPhotos.length - 1) * GALLERY_GAP_PX;
                        const actualHeight = (containerWidth - gapWidth) / totalAspect;
                        
                        // Штрафуем за отклонение от целевой высоты
                        const heightDiff = Math.abs(actualHeight - targetHeight) / targetHeight;
                        
                        // Штрафуем за слишком малое количество фото в ряду
                        const countPenalty = rowPhotos.length < 2 ? 0.3 : 0;
                        
                        // Штрафуем за слишком большое отклонение высоты
                        const extremeHeightPenalty = actualHeight > targetHeight * 2 ? 1 : 0;
                        
                        return heightDiff + countPenalty + extremeHeightPenalty;
                    };

                    // Сначала группируем контент по разделам
                    const sections = [];
                    let currentSection = [];
                    
                    for (const item of allContent) {
                        if (item.type === 'divider') {
                            if (currentSection.length > 0) {
                                sections.push({ type: 'photos', items: currentSection });
                                currentSection = [];
                            }
                            sections.push({ type: 'divider', item: item });
                        } else {
                            currentSection.push(item);
                        }
                    }
                    if (currentSection.length > 0) {
                        sections.push({ type: 'photos', items: currentSection });
                    }

                    // Обрабатываем каждую секцию отдельно
                    for (const section of sections) {
                        if (section.type === 'divider') {
                            // Добавляем разделитель
                            rows.push({ 
                                type: 'dividerRow', 
                                content: section.item, 
                                uniqueId: section.item.timestamp 
                            });
                            continue;
                        }

                        // Для секции с фото используем оптимизированное распределение
                        const sectionPhotos = section.items.filter(item => 
                            item.type !== 'divider' && item.aspectRatio > 0 && item.url
                        );
                        
                        if (sectionPhotos.length === 0) continue;
                        
                        const photoRows = distributePhotosOptimally(
                            sectionPhotos, 
                            TARGET_ROW_HEIGHT, 
                            containerWidth
                        );
                        
                        // Преобразуем ряды в нужный формат
                        for (const row of photoRows) {
                            const rowContent = row.photos.map(photo => ({
                                ...photo,
                                height: row.height,
                                width: photo.aspectRatio * row.height,
                            }));
                            
                            rows.push({ 
                                type: 'photoRow', 
                                content: rowContent, 
                                uniqueId: Date.now() + Math.random() 
                            });
                        }
                    }
                    
                    return rows;
                }, [allContent, containerWidth]);

                const isDraggingCurrent = (uniqueId) => isReorderMode && dragItemUniqueId.current === uniqueId;
                const isDragOverTarget = (uniqueId) => isReorderMode && dragOverItemUniqueId.current === uniqueId && dragItemUniqueId.current !== uniqueId;

                return (
                    <div className="py-0 md:py-0 pt-0 md:pt-0">
                        <div 
                            ref={albumRef}
                            className="w-full" 
                            onDrop={isReorderMode && isAdmin ? handleDrop : undefined}
                            onDragOver={isReorderMode && isAdmin ? handleDragOver : undefined}
                        >
                            {containerWidth === 0 && allContent.length > 0 && <CalculationSpinner />}
                            
                            {(containerWidth > 0 && justifiedRows.length > 0) && justifiedRows.map((rowWrapper) => {
                                const key = rowWrapper.uniqueId;

                                if (rowWrapper.type === 'dividerRow') {
                                    const divider = rowWrapper.content;
                                    return (
                                        <div 
                                            key={key} 
                                            className={`w-full my-0 flex items-center justify-center relative ${
                                                isReorderMode ? 'cursor-grab py-2' : ''
                                            } ${
                                                isDraggingCurrent(divider.timestamp) ? 'opacity-50 border-2 border-indigo-500 scale-[0.98]' : ''
                                            } ${
                                                isDragOverTarget(divider.timestamp) ? 'border-2 border-dashed border-green-500' : ''
                                            }`}
                                            draggable={isReorderMode && isAdmin}
                                            onDragStart={isReorderMode && isAdmin ? (e) => handleDragStart(e, divider.timestamp) : undefined}
                                            onDragEnter={isReorderMode && isAdmin ? (e) => handleDragEnter(e, divider.timestamp) : undefined}
                                        >
                                            <div className="w-full h-px bg-gray-300 mx-4 hidden sm:block"></div>
                                            <h2 className="text-2xl font-extrabold text-gray-800 px-4 py-2 inline-block text-center whitespace-nowrap">
                                                {divider.text}
                                            </h2>
                                            <div className="w-full h-px bg-gray-300 mx-4 hidden sm:block"></div>
                                            
                                            {isReorderMode && isAdmin && (
                                                <div 
                                                    className="absolute top-1/2 left-2 transform -translate-y-1/2 bg-black/50 text-white p-1 rounded-full opacity-100 transition duration-200 cursor-grab z-20"
                                                    title="Перетащить разделитель"
                                                >
                                                    <GripVertical className="h-4 w-4" />
                                                </div>
                                            )}
                                            {isDeleteMode && isAdmin && (
                                                <button
                                                    onClick={(e) => { 
                                                        e.stopPropagation(); 
                                                        deletePhoto(selectedAlbum.id, divider);
                                                    }}
                                                    className="absolute top-1/2 right-2 transform -translate-y-1/2 bg-red-600 text-white p-1.5 rounded-full opacity-100 transition duration-200 hover:bg-red-700 shadow-lg z-20"
                                                    title="Удалить разделитель"
                                                >
                                                    <Trash2 className="h-4 w-4" />
                                                </button>
                                            )}
                                        </div>
                                    );
                                }

                                const row = rowWrapper.content;
                                return (
                                    <div
                                        key={key}
                                        className="flex overflow-hidden"
                                        style={{ marginBottom: `${GALLERY_GAP_PX}px` }}
                                    >
                                        {row.map((image, imageIndex) => {
                                            const uniqueId = image.timestamp;

                                            return (
                                                <div 
                                                    key={uniqueId} 
                                                    onClick={!isDeleteMode && !isReorderMode ? () => onOpenImage(image) : undefined}
                                                    draggable={isReorderMode && isAdmin}
                                                    onDragStart={isReorderMode && isAdmin ? (e) => handleDragStart(e, uniqueId) : undefined}
                                                    onDragEnter={isReorderMode && isAdmin ? (e) => handleDragEnter(e, uniqueId) : undefined}
                                                    className={`cursor-pointer relative overflow-hidden bg-gray-200 transition duration-150 shadow-md ${
                                                        isReorderMode && isAdmin ? 'cursor-grab active:cursor-grabbing' : 'hover:opacity-90'
                                                    } ${
                                                        isDraggingCurrent(uniqueId) ? 'opacity-50 border-4 border-indigo-500 scale-95' : ''
                                                    } ${
                                                        isDragOverTarget(uniqueId) ? 'border-4 border-dashed border-green-500' : ''
                                                    }`}
                                                    style={{
                                                        height: `${image.height}px`,
                                                        width: `${image.width}px`,
                                                        marginRight: imageIndex < row.length - 1 ? `${GALLERY_GAP_PX}px` : '0',
                                                    }}
                                                >
                                                    <img 
                                                        src={image.url} 
                                                        alt={image.caption || `Фото ${key}-${imageIndex + 1}`} 
                                                        className="w-full h-full object-cover" 
                                                        style={{ width: '100%', height: '100%' }}
                                                        onError={(e) => { 
                                                            e.target.onerror = null; 
                                                            e.target.src = "https://placehold.co/400x400/CCCCCC/333333?text=URL+недоступен"; 
                                                        }}
                                                    />
                                                    
                                                    {isDeleteMode && isAdmin && (
                                                        <button
                                                            onClick={(e) => { 
                                                                e.stopPropagation();
                                                                deletePhoto(selectedAlbum.id, image);
                                                            }}
                                                            className="absolute top-2 right-2 bg-red-600 text-white p-1.5 rounded-full opacity-100 transition duration-200 hover:bg-red-700 shadow-lg z-20"
                                                            title="Удалить фото"
                                                        >
                                                            <Trash2 className="h-4 w-4" />
                                                        </button>
                                                    )}

                                                    {isReorderMode && isAdmin && (
                                                        <div 
                                                            className="absolute top-1/2 left-2 transform -translate-y-1/2 bg-black/50 text-white p-1 rounded-full opacity-0 group-hover:opacity-100 transition duration-200 cursor-grab z-20"
                                                            title="Перетащить"
                                                        >
                                                            <GripVertical className="h-4 w-4" />
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                );
                            })}
                        </div>

                        {allContent.length === 0 && (
                             <div className="mx-4 sm:mx-6 lg:mx-8 text-center py-20 bg-gray-50 rounded-xl mt-8 border border-dashed border-gray-300">
                                <ImageIcon className="w-12 h-12 text-gray-400 mx-auto" />
                                <h3 className="mt-2 text-lg font-medium text-gray-900">Этот альбом пуст</h3>
                                {isAdmin && (
                                    <p className="mt-1 text-sm text-gray-500">
                                        Добавьте первое фото или разделитель, используя кнопки вверху.
                                    </p>
                                )}
                                {!isAdmin && (
                                    <p className="mt-1 text-sm text-gray-500">
                                        Администратор скоро добавит контент.
                                    </p>
                                )}
                            </div>
                        )}
                    </div>
                );
            };

            // --- Вид: Главная страница (Список альбомов) ---
            const HomeView = () => {
                // Фильтрация: Админ видит всё, остальные только не скрытые
                const visibleAlbums = isAdmin ? albums : albums.filter(a => !a.hidden);

                return (
                    <div className="px-4 sm:px-6 lg:px-8 py-8">
                        <div className="flex justify-between items-center mb-8 border-b pb-2">
                            <h2 className="text-3xl font-extrabold text-gray-900">Все альбомы</h2>
                            
                            {/* Кнопка сортировки альбомов */}
                            {isAdmin && visibleAlbums.length > 1 && (
                                <button 
                                    onClick={toggleAlbumReorderMode}
                                    className={`flex items-center px-3 py-1.5 text-sm font-medium rounded-lg transition ${
                                        isAlbumReorderMode 
                                            ? 'bg-indigo-600 text-white shadow-lg ring-2 ring-offset-1 ring-indigo-500' 
                                            : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-50'
                                    }`}
                                >
                                    <ArrowUpDown className="w-4 h-4 mr-2" />
                                    {isAlbumReorderMode ? 'Сохранить порядок' : 'Сортировать'}
                                </button>
                            )}
                        </div>
                        
                        {visibleAlbums.length === 0 ? (
                            <div className="text-center py-20 bg-white rounded-xl border border-dashed border-gray-300">
                                <ImageIcon className="w-12 h-12 text-gray-400 mx-auto" />
                                <h3 className="mt-2 text-lg font-medium text-gray-900">Нет доступных альбомов</h3>
                                {isAdmin && (
                                    <p className="mt-1 text-sm text-gray-500">
                                        Вы можете создать первый альбом.
                                    </p>
                                )}
                            </div>
                        ) : (
                            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                                {visibleAlbums.map(album => (
                                    <AlbumCard key={album.id} album={album} />
                                ))}
                            </div>
                        )}

                        {/* Подсказка для режима сортировки */}
                        {isAlbumReorderMode && (
                            <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-indigo-900 text-white px-6 py-3 rounded-full shadow-xl z-50 animate-bounce">
                                Перетаскивайте альбомы, чтобы изменить их порядок
                            </div>
                        )}
                    </div>
                );
            };

            if (error && error.isCritical) {
                return (
                    <div className="flex items-center justify-center min-h-screen bg-gray-100 p-4">
                        <div className="bg-red-100 border-l-4 border-red-500 p-6 rounded-xl text-red-900 shadow-2xl max-w-lg">
                            <h1 className="text-2xl font-bold mb-3">{error.name}</h1>
                            <p className="text-red-800 whitespace-pre-wrap">{error.message}</p>
                            <p className="mt-4 text-sm font-semibold">Пожалуйста, убедитесь, что переменные Firebase правильно настроены.</p>
                        </div>
                    </div>
                );
            }
            
            if (!authReady || (loading && !error)) {
                return <LoadingSpinner />;
            }

            if (error && !error.isCritical) {
                return (
                    <div className="p-8 text-center text-red-600 bg-red-100 rounded-xl m-10">
                        <strong>{error.name || 'Ошибка'}:</strong> {error.message || 'Произошла неизвестная ошибка.'}
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gray-50 font-sans">
                    <header className="bg-white shadow-md sticky top-0 z-10">
                        <div className="px-4 sm:px-6 lg:px-8 py-3 flex justify-between items-center">
                            <div className="flex items-center">
                                <div className="flex items-center">
                                    <h1 className="text-3xl font-bold flex items-center">
                                        <img src="https://lh3.googleusercontent.com/pw/AP1GczPF0dFAtwx7eDD_mrrrIwaD1QJbvoSuDsnIg01fnRExuJrtZe0ZmhsofzhK7k9L0_0WrAnV1FtTSAfva4dx6we2GidqtHd5V2HSLAzeyDahzmxa4dW8h3uoszZzAEJkMlZQYa_HRV4cBrkO3weGaIjg0A=w180-h180-s-no?authuser=0" alt="Логотип" className="inline-block w-6 h-6 mr-2 align-middle" />
                                        <span className="text-xl font-bold text-gray-800">Leon H-Arts</span>
                                    </h1>
                                </div>

                                {currentView === 'album' && selectedAlbum && (
                                    <div className="ml-4 pl-4 border-l border-gray-200 flex items-center flex-wrap">
                                        <button 
                                            onClick={handleGoHome} 
                                            className="text-indigo-600 hover:text-indigo-800 transition text-sm font-medium"
                                            aria-label="Вернуться к альбомам"
                                        >
                                            Альбомы
                                        </button>
                                        <span className="text-gray-500 mx-2 text-sm">/</span>
                                        <span className="text-gray-900 font-semibold text-sm truncate max-w-[150px] sm:max-w-xs" title={selectedAlbum.name}>{selectedAlbum.name}</span>
                                        <span className="text-gray-500 ml-3 text-xs hidden sm:inline-block">({selectedAlbum.images.filter(i => i.type !== 'divider').length} фото)</span>
                                    </div>
                                )}
                            </div>
                            
                            <div className="flex items-center space-x-3">
                                {isAdmin && currentView === 'album' && selectedAlbum && (
                                    <>
                                        <button
                                            onClick={toggleDeleteMode}
                                            className={`p-2 rounded-full transition shadow-md ${isDeleteMode 
                                                ? 'bg-red-500 text-white hover:bg-red-600' 
                                                : 'bg-white text-gray-700 hover:bg-gray-100'}`}
                                            title="Включить/Выключить режим удаления"
                                            aria-pressed={isDeleteMode}
                                        >
                                            <Trash2 className="h-5 w-5" />
                                        </button>

                                        <button
                                            onClick={toggleReorderMode}
                                            className={`p-2 rounded-full transition shadow-md ${isReorderMode 
                                                ? 'bg-indigo-500 text-white hover:bg-indigo-600' 
                                                : 'bg-white text-gray-700 hover:bg-gray-100'}`}
                                            title="Включить/Выключить режим изменения порядка"
                                            aria-pressed={isReorderMode}
                                        >
                                            <ArrowUpDown className="h-5 w-5" />
                                        </button>
                                        
                                        <button
                                            onClick={handleOpenAddDividerModal}
                                            className="p-2 border border-gray-300 text-sm font-medium rounded-full text-gray-700 bg-white hover:bg-gray-100 transition shadow-sm"
                                            title="Добавить разделитель (Глава)"
                                            disabled={isDeleteMode || isReorderMode}
                                        >
                                            <Pencil className="h-5 w-5" />
                                        </button>
                                    </>
                                )}

                                {isAdmin && (
                                    <>
                                        <button
                                            onClick={handleOpenAddPhotoModal}
                                            className="flex items-center p-2 border border-gray-300 text-sm font-medium rounded-full shadow-sm text-gray-700 bg-white hover:bg-gray-100 transition"
                                            disabled={isDeleteMode || isReorderMode}
                                            title="Добавить фото"
                                        >
                                            <ImageIcon className="h-5 w-5" />
                                        </button>
                                        <button
                                            onClick={handleOpenAddAlbumModal}
                                            className="flex items-center p-2 border border-gray-300 text-sm font-medium rounded-full text-gray-700 bg-white hover:bg-gray-100 transition shadow-sm"
                                            title="Создать альбом"
                                        >
                                            <Plus className="h-5 w-5" />
                                        </button>
                                    </>
                                )}
                                
                                {!isAdmin && (
                                    <button
                                        onClick={handleOpenLoginModal}
                                        className="flex items-center px-4 py-2 border border-indigo-300 text-sm font-medium rounded-full text-indigo-700 bg-indigo-100 hover:bg-indigo-200 transition shadow-sm"
                                        title="Войти как Администратор"
                                    >
                                        <Key className="h-5 w-5 mr-2" />
                                        Админ Вход
                                    </button>
                                )}
                            </div>
                        </div>
                    </header>

                    <main className="pb-12">
                        {currentView === 'home' ? <HomeView /> : <AlbumPhotoView onOpenImage={handleOpenImage} />}
                    </main>

                    <AdminLoginModal />
                    <RenameAlbumModal />
                    <AddAlbumModal />
                    <AddPhotoModal />
                    <AddDividerModal />
                    <DeleteAlbumConfirmModal />
                    
                    <ImageModal 
                        image={enlargedImage}
                        onClose={handleCloseImage}
                        onSaveCaption={updatePhotoCaption}
                        albumId={selectedAlbum?.id}
                        onNext={handleNextImage}
                        onPrev={handlePrevImage}
                        isAdmin={isAdmin}
                    />
                </div>
            );
        };
        
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
